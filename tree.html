<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Context Graph Viewer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Doto:wght@100..900&display=swap');

        * {
            font-family: "Doto", sans-serif;
            text-shadow: 0px 0px 3px black, 0px 0px 10px #fffa;
        }

        input,
        select,
        button,
        textarea,
        select,
        label {
            font-family: "Doto", sans-serif;
            font-style: normal;
            background: transparent !important;
            border: 1px dashed #333 !important;
            color: white !important;
            line-height: 1.75;
            font-size: 0.75rem;
            height: 2rem;
            box-sizing: border-box;
            backdrop-filter: blur(3px);
            border-top: unset !important;
            border-left: unset !important;

        }

        option {
            font-family: "Doto", sans-serif;
            font-style: normal;
            background: black !important;
            border: 1px dashed #333 !important;
            color: white !important;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            color: #eee;
            font-family: Arial, Helvetica, sans-serif;
        }

        #ui {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            box-sizing: border-box;
            justify-content: space-between;
            z-index: 10;
        }

        #light2 {

            position: fixed;
            height: calc(100vh - 28rem);
            bottom: 10rem;
            left: 5rem;
            width: 50px;
            border-radius: 1rem;
            filter: blur(5px) brightness(5);
            display: none;
            box-shadow: inset 0px -50px 20px #c8fff7aa, 0px 0px 100px #00ff04, 0px 0px 300px #2600ffbd, 0px 0px 500px #aeffd780, 0px 0px 700px #ff835aa3;
            background: rgb(255, 255, 255);
        }
        #light1 {

            position: fixed;
            width: calc(100vw - 40rem);
            bottom: 5rem;
            left: 10rem;
            height: 50px;
            border-radius: 1rem;
            filter: blur(5px) brightness(5);
            display: none;
            box-shadow: inset 0px -50px 20px #c8fff7aa, 0px 0px 100px #00ff04, 0px 0px 300px #2600ffbd, 0px 0px 500px #aeffd780, 0px 0px 700px #ff835aa3;
            background: rgb(255, 255, 255);
        }

        .column {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
            border-radius: 6px;
        }

        #ui label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-right: 4px;
        }

        #ui select,
        #ui button {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 2px 6px;
            font-size: 0.9rem;
        }

        *::-webkit-scrollbar {
            display: none;
        }

        * {
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        #selectednode {
            width: 0px;
            font-size: 0.5rem;
            opacity: 0.5;
            display: none;
            position: fixed;
            top: 3em;
            left: 0;
            width: auto;
            height: calc(60% - 3em);
            overflow: auto;
            padding: 8px;
            font-size: 0.8rem;
            border-top-left-radius: 6px;
            box-sizing: border-box;
            white-space: pre-wrap;
            z-index: 9;
        }

        .row {
            display: flex;
            flex-flow: wrap;
        }

        #timeindicators {

            font-family: "Doto", sans-serif;
            font-style: normal;
            background: transparent !important;
            color: white !important;
        }

        .ref-link {
            pointer-events: all !important;
        }

        #detailPanel {
            width: 0px;
            font-size: 0.5rem;
            position: fixed;
            bottom: 0;
            left: 0;
            top: 8em;
            bottom: 0;
            width: 500px;
            max-width: 50%;
            overflow: auto;
            padding: 8px;
            font-size: 0.75rem;
            border-top-right-radius: 6px;
            box-sizing: border-box;
            z-index: 9;
            display: inline-table;
            pointer-events: none;
            text-shadow: 0px 0px 2px black;
        }

        #detailPanel table {
            width: 100%;
            border-collapse: collapse;
        }

        #detailPanel td {
            vertical-align: top;
            padding-left: 0.5rem;
        }

        #detailPanel td:first-child {
            font-weight: bold;
            text-align: right;
            padding-right: 0.5rem;
            padding-left: 0rem;
            border-right: 1px dashed #555;
        }

        .sidebar-item-highlight::after {
            content: '';
            left: -0.5rem;
            width: 1px;
            height: calc(100% - 1rem);
            background: white;
            animation: expand 0.2s ease-in-out;
        }

        @keyframes expand {
            0% {
                width: 0rem;
            }

            50% {
                width: 0.25rem;
            }

            100% {
                width: 0rem;
            }
        }

        .sidebar-header {
            display: flex;
            flex-flow: column;
        }

        .sidebar-header:hover {
            background: #333;
        }

        .json-section>div {
            margin: 2px 0;
        }

        a.ref-link {
            color: #6cf;
            text-decoration: underline;
            cursor: pointer;
            margin-right: 6px;
        }

        canvas {
            display: block;
        }
    </style>

    <!-- import map for three.js -->
    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
      "three/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.js",
      "three/FlyControls": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/FlyControls.js"
    }
  }
  </script>
</head>

<body>
    <div id="light1"></div>
    <div id="light2"></div>
    <!-- ─── CONTROL BAR ─────────────────────────────────────────────────── -->
    <div id="ui" style="mix-blend-mode:difference;">
        <div class="column">

            <div class="row">
                <select id="ageFilter">
                    <option value="all">All</option>
                    <option value="h1">Last hour</option>
                    <option value="d1">Last 24 h</option>
                    <option value="w1">Last 7 days</option>
                    <option value="m1">Last 30 days</option>
                </select>

                <select id="domainFilter"></select>
                <select id="componentFilter"></select>
                <select id="semanticFilter"></select>
            </div>

            <div class="row">
                <select id="fileSelector">\
                </select>
                <button id="timeToggle">Time Mode</button>
                <button id="modeswitch">Tree Mode</button>

            </div>

        </div>
        <div class="column">
            <div class="row">

                <div id="timeIndicators" style="background:transparent;           
border:1px solid #555; line-height:1.75!important;padding: 0.25rem; color:#fff; padding:0 0.5rem;
                        border: 1px dashed #333;border-top:unset;border-right:unset;

            height:2rem;">
                    <span id="nowTime">// <b>now</b> </span>
                    <span id="viewTime">// <b>view</b> </span>
                </div>
            </div>
        </div>
    </div>
    <div id="datadrop" style="position:fixed;bottom:4px;left:4px;
            font:600 0.8rem/1.2 monospace;
            color:#0f0;pointer-events:none;z-index:999;">
        (pinch delta x,y will appear here)
    </div>

    <!-- ─── HOVER JSON PANE ─────────────────────────────────────────────── -->
    <div id="selectednode" style="">// Hover or click a node…</div>

    <!-- ─── DETAIL TABLE PANEL ─────────────────────────────────────────── -->
    <div id="detailPanel" style=""></div>

    <!-- ─── SIDEBAR MODULE LIST ─────────────────────────────────────────── -->
    <div id="sidebarList" style="
           position: fixed;
           top: 2rem;
           right: 0;
           bottom: 0;
           width: 300px;
           overflow-y: auto;
           color: #eee;
           font-size: 0.75rem;
           backdrop-filter: blur(3px);
           z-index: 8;
         ">
        <!-- dynamically populated -->
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- ─── THREE.JS + LOGIC ─────────────────────────────────────────────── -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/OrbitControls';
        import { FlyControls } from 'three/FlyControls';
        import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';
        const { FaceLandmarker, HandLandmarker, FilesetResolver } = vision;

        //////////////////////////////////////////////////////////////////////
        // CONFIG
        //////////////////////////////////////////////////////////////////////
        const LAYOUT_CONFIG = {
            // 60000 ms = 1 minute → 1 Y-unit
            msPerUnit: 10 * 1000,

            // you can speed up spawning independently of drift
            spawnFactor: 1.0,

            // you can speed up (or slow down) drift separately
            driftFactor: 1.0,

            maxXZRadius: 200,
            minSphereY: 0
        };
        const DISPLAY_CONFIG = {
            sphereRadius: 2,
            sphereSegments: 8,
            lineBaseOpacity: 0.3,
            hoverHighlightOpacity: 0.5,
            chainDelay: 200,
            maxChainDepth: 50,
            fadeOutDuration: 1000
        };
        // ─── COLOR CONFIG ─────────────────────────────────────────────────
        const COLOR_CONFIG = {
            // which field on each object to color by:
            colorBy: 'component',
            // HSL constants:
            saturation: 0.5,
            lightness: 0.2
        };
        // ─── BRAIN MODE CONFIG ────────────────────────────────────────────────
        const BRAIN_CONFIG = {
            // how much vertical spacing per BFS‐depth level
            depthSpacing: 350,
            initialSpread: 1200,
            // scale factor for node diameter (tweak so they look reasonable)
            scaleFactor: 0.01
        };

        //////////////////////////////////////////////////////////////////////
        // UI & STATE
        //////////////////////////////////////////////////////////////////////
        const nowLbl = document.getElementById('nowTime');
        const viewLbl = document.getElementById('viewTime');

        /* wheel → Y-units. 0.05 ≃  0.5  sec per scroll-tick with msPerUnit = 10 000 ms */
        const SCROLL_SPEED = 0.5;
        const fileSelector = document.getElementById('fileSelector');

        const ageSel = document.getElementById('ageFilter');
        const domainSel = document.getElementById('domainFilter');
        const componentSel = document.getElementById('componentFilter');
        const semanticSel = document.getElementById('semanticFilter');

        // we'll keep a master list of all objects
        let allData = [];
        const timeToggle = document.getElementById('timeToggle');
        const selPane = document.getElementById('selectednode');
        const detailPanel = document.getElementById('detailPanel');
        const BASE_EDGE_GREY = 0.25;
        // ─── CORE STATE ───────────────────────────────────────────────────────
        let pickableMeshes = [];
        let visibleMeshes = [];
        let initialLoadDone = false;

        // ─── BRAIN vs TREE MODE ─────────────────────────────────────────────
        const modeSwitch = document.getElementById('modeswitch');
        let brainMode = true;
        let timeMode = false;   // ← add this

        let freeNodeIx = 0;
        let freeEdgeIx = 0;
        let seenIds = new Set();

        let lastSize = 0;
        let lastETag = '';
        const POLL_INTERVAL = 1000;
        let scrollVelocity = 0;
        const SCROLL_ACCEL = 0.002;  // tweak: how much wheel delta becomes velocity
        const SCROLL_FRICTION = .99;   // per-frame multiplier (<1 to slow down)
        const SCROLL_DIR = -1;
        let scrollBoost = 100;
        let lastWheelDir = 0;
        let lastWheelTime = 0;

        // ─── pinch‑zoom globals ───────────────────────────────────────────────

        let leftPinchActive = false;           // “thumb & index are touching”
        let leftPinchStartMid = null;            // {x,y} at the frame the pinch began
        let leftPinchDelta = { x: 0, y: 0 };  // running Δ written to #datadrop
        const HAND_RENDER_DEPTH = 5; // world units
        let prevLeftMid = null;
        let prevRightMid = null;
        let prevHandsMidDist = null;
        const HEAD_SMOOTH = 0.1;   // 0–1 low‑pass factor for head‐pose
        const PINCH_THRESHOLD = 0.08;  // pinch detection threshold
        const ZOOM_SENSITIVITY = 500.0;  // two‑hand pinch → zoom scale
        const ROTATE_SENSITIVITY = 4.0;  // one‑hand pinch drag → orbit speed

        const HAND_DRAW_DISTANCE = 5;     // how far in front of camera we project landmarks
        let prevSingleMid = null;
        const HEAD_SMOOTH_FACTOR = 0.1;
        const headSmooth = { y: 0, p: 0, r: 0 };
        const HEAD_ROTATION_SENSITIVITY = 0.8;

        let headDY = 0, headDP = 0, headDR = 0;
        let lastLeftPinchMid = null;
        let lastTwoHandPinchDist = null;
        const ROT_SENSITIVITY = 2.0;
        const PAN_SENSITIVITY = 50.0;
        const BOOST_INCREMENT = 50;    // how much boost you gain per rapid event
        const BOOST_DECAY = 0.75;   // how quickly boost winds down
        const BOOST_MAX = 1000;      // cap on boost multiplier
        const MAX_INSTANCES_HARD = 0xFFFF;
        const HARD_MAX_NODES = 5000;
        let prevCount = 0;
        let remoteSize = 0;
        let prevLineCount = 0;
        const LAST_KB = 16;
        const WANT_LINES = 120;          // how many recent JSON-lines we care about
        const RANGE_KB_MIN = 64;           // 1st attempt → 64 KB tail
        const RANGE_KB_MAX = 512;          // hard ceiling for the tail window
        let tailKB = RANGE_KB_MIN; // grows when we miss, shrinks when we hit
        let lastContextId = null;
        let lastOffset = 0;
        let leftover = "";    // carry over any partial line
        const OVERLAP = 1024;   // bytes to rewind so you don't cut a JSON in half
        const STORAGE_KEY = 'selectedContextFile';
        let nodes = [];
        let nodeMap = new Map();
        let edges = [];

        let hueMapCurrent = {};
        let maxConnCurrent = 1;
        // ─── right‑hand pinch → orbit ──────────────────────────────
        let rightPinchActive   = false;
        let rightPinchStartMid = null;          // {x,y} of pinch‑mid at activation
        const RIGHT_ROTATE_SENSITIVITY = 4.0;   // tweak to taste
        let cameraTween = null;
        let rightPinchStartVec = null;
        let selectedId = null;
        let previousHoveredId = null;
        // ←── Add this so instMesh is visible everywhere ──→
        let instMesh = null;
        let instEdge = null;
        let hovered = null;
        let hoveredIdx = null;
        let yScrollOffset = 0;
        // last time we applied that drift
        let lastDriftT = Date.now();
        // ←── PICKABLE INSTANCES SETUP ──→
        pickableMeshes.length = 0;
        const comps = [...new Set([...nodeMap.values()].map(n => n.data.component))];
        const hueMap = Object.fromEntries(comps.map((c, i) => [c, i / comps.length]));
        const MS_PER_UNIT = LAYOUT_CONFIG.msPerUnit;  // ms per world‐unit, e.g. 10 000
        let autoScrollEnabled = true;
        const sidebar = document.getElementById('sidebarList');
        sidebar.addEventListener('scroll', () => {
            const nearBottom =
                sidebar.scrollTop + sidebar.clientHeight >=
                sidebar.scrollHeight - 5;
            autoScrollEnabled = nearBottom;
        });
        function getContextFileUrl(cacheBust = false) {
            // Use the same scheme, host and port that loaded the page:
            const origin = window.location.origin;
            // Which file to load (defaults to context.jsonl):
            const fn = fileSelector.value || 'context.jsonl';
            // Build a cache‑busted URL if requested:
            const url = `${origin}/${fn}` + (cacheBust ? `?_=${Date.now()}` : '');
            console.log('[getContextFileUrl] →', url);
            return url;
        }
        // helper to recompute each instance's matrix in 3D
        function updateBrainMatrices() {
            const tmpQuat = new THREE.Quaternion();
            nodeMap.forEach((entry, id) => {
                // 1) diameter ∝ sqrt(byteSize)
                const size = JSON.stringify(entry.data).length;
                const dia = Math.sqrt(size) * BRAIN_CONFIG.scaleFactor;

                // 2) build scale vector
                const scale = new THREE.Vector3(dia, dia, dia);

                // 3) position is already set in entry.pos (x,y,z)
                const mat = new THREE.Matrix4().compose(
                    entry.pos,
                    tmpQuat,
                    scale
                );
                instMesh.setMatrixAt(entry._instanceIndex, mat);
            });
            instMesh.instanceMatrix.needsUpdate = true;
        }
        async function populateFileSelector() {
            try {
                const res = await fetch(window.location.origin + '/', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const txt = await res.text();
                let files = [];

                // 1) try JSON
                try {
                    const arr = JSON.parse(txt);
                    if (Array.isArray(arr)) {
                        files = arr;
                    } else {
                        throw new Error('JSON is not an array');
                    }
                } catch (jsonErr) {
                    console.warn('Could not parse / as JSON, falling back to HTML scrape:', jsonErr);
                    // 2) fallback — pull href="context_....jsonl"
                    const regex = /href="(context(?:_-?\d+)?\.jsonl)"/g;
                    let m;
                    while ((m = regex.exec(txt))) {
                        files.push(m[1]);
                    }
                }

                // 3) dedupe & filter & sort
                const unique = Array.from(new Set(files))
                    .filter(f => /^context(?:_-?\d+)?\.jsonl$/.test(f))
                    .sort();

                // 4) rebuild the <select>
                fileSelector.innerHTML = unique
                    .map(f => `<option value="${f}">${f}</option>`)
                    .join('');

                // 5) restore last selection if present
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved && unique.includes(saved)) {
                    fileSelector.value = saved;
                }

            } catch (err) {
                console.warn('populateFileSelector failed; keeping existing <option>s:', err);
            }
        }

        // call loadGraph() whenever user picks a file
        fileSelector.addEventListener('change', () => {
            localStorage.setItem(STORAGE_KEY, fileSelector.value);
            loadGraph();
        });

        // on startup: populate, restore or default, then load
        ; (async () => {
            await populateFileSelector();
            if (!localStorage.getItem(STORAGE_KEY) && fileSelector.options.length) {
                fileSelector.value = fileSelector.options[0].value;
            }
            // do the very first full load
            await loadGraph();
            // now that allData is populated, mark the sentinel
            if (allData.length) {
                lastContextId = allData[allData.length - 1].context_id;
            }
            // now start polling
            setInterval(pollForNew, POLL_INTERVAL);
        })();


        function runForceLayout() {
            // 1️⃣ build nodes & links arrays
            const nodes = [...nodeMap.entries()].map(([id, entry]) => ({
                id,
                x: entry.pos.x,
                y: entry.pos.z   // map z→y for 2D layout
            }));
            const links = edges.map(e => ({ source: e.source, target: e.target }));

            // 2️⃣ stash current positions for tweening
            const layoutTime = performance.now();
            nodeMap.forEach(entry => {
                entry.prevPos = entry.pos.clone();
            });

            // 3️⃣ run a D3 force simulation
            const sim = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(-30))
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(100)
                    .strength(1))
                .force('center', d3.forceCenter(0, 0))
                .stop();

            for (let i = 0; i < 200; ++i) sim.tick();

            // 4️⃣ write back new target positions
            nodes.forEach(n => {
                const entry = nodeMap.get(n.id);
                entry.pos.x = n.x;
                entry.pos.z = n.y;
                // kick off a 600 ms tween
                entry.tweenStart = layoutTime;
                entry.tweenDuration = 600;
            });

            // 5️⃣ (No immediate mesh update here – animate() will drive it)
        }

        // ─── New helper: rebuild all edges based on updated nodeMap ──────────
        function updateEdgeMeshes() {
            if (!instEdge) initEdges();

            const mat = new THREE.Matrix4();
            const axisY = new THREE.Vector3(0, 1, 0);
            let ei = 0;

            edges.forEach(e => {
                const src = nodeMap.get(e.source);
                const tgt = nodeMap.get(e.target);
                if (!src || !tgt) return;

                // compute direction & length
                const dir = new THREE.Vector3().subVectors(tgt.pos, src.pos);
                const len = dir.length();
                if (!len) return;

                // build the orientation quaternion
                const quat = new THREE.Quaternion()
                    .setFromUnitVectors(axisY, dir.clone().normalize());

                // compose the instance matrix (thin box from src → tgt)
                mat.compose(src.pos, quat, new THREE.Vector3(0.2, len, 0.2));
                instEdge.setMatrixAt(ei, mat);

                // copy the source node's color
                const srcIdx = src._instanceIndex;
                const r = instMesh.instanceColor.getX(srcIdx);
                const g = instMesh.instanceColor.getY(srcIdx);
                const b = instMesh.instanceColor.getZ(srcIdx);
                instEdge.instanceColor.setXYZ(ei, r, g, b);

                ei++;
            });

            // upload counts + attributes
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            instEdge.instanceColor.needsUpdate = true;
        }

        // 1️⃣ Build the nested list from allData after each full load
        // ─── Replacement buildSidebarList ──────────────────────────────────────
        function buildSidebarList(data) {
            const container = document.getElementById('sidebarList');
            container.innerHTML = '';

            // group by context_id
            const groups = data.reduce((acc, o) => {
                (acc[o.context_id] ??= []).push(o);
                return acc;
            }, {});

            // recursive renderer for arbitrary-depth JSON
            function renderObject(obj, parent) {
                if (obj === null || typeof obj !== 'object') {
                    // primitive → read-only input
                    let inp;
                    if (typeof obj === 'boolean') {
                        inp = document.createElement('input');
                        inp.type = 'checkbox';
                        inp.checked = obj;
                        inp.disabled = true;
                    } else if (typeof obj === 'number') {
                        inp = document.createElement('input');
                        inp.type = 'number';
                        inp.value = obj;
                        inp.readOnly = true;
                    } else {
                        inp = document.createElement('input');
                        inp.type = 'text';
                        inp.value = obj;
                        inp.readOnly = true;
                    }
                    inp.style = 'margin:2px 0; width:100%;';
                    parent.appendChild(inp);

                } else if (Array.isArray(obj)) {
                    obj.forEach((item, i) => {
                        const section = document.createElement('div');
                        section.style = 'margin-left:12px; border-left:1px solid #444; padding-left:6px;';
                        const title = document.createElement('div');
                        title.textContent = `[${i}]`;
                        title.style = 'font-weight:bold; cursor:pointer;';
                        section.appendChild(title);
                        const content = document.createElement('div');
                        content.style = 'display:none;';
                        renderObject(item, content);
                        section.appendChild(content);
                        title.onclick = () => {
                            content.style.display = content.style.display === 'none' ? 'block' : 'none';
                        };
                        parent.appendChild(section);
                    });

                } else {
                    // object → each key as collapsible
                    Object.entries(obj).forEach(([key, val]) => {
                        const section = document.createElement('div');
                        section.style = 'margin-left:12px; border-left:1px solid #444; padding-left:6px;';
                        const title = document.createElement('div');
                        title.textContent = key;
                        title.style = 'font-weight:bold; cursor:pointer;';
                        section.appendChild(title);
                        const content = document.createElement('div');
                        content.style = 'display:none;';
                        renderObject(val, content);
                        section.appendChild(content);
                        title.onclick = () => {
                            content.style.display = content.style.display === 'none' ? 'block' : 'none';
                        };
                        parent.appendChild(section);
                    });
                }
            }

            for (const [ctxId, objs] of Object.entries(groups)) {
                // header
                const header = document.createElement('div');
                header.id = `header-${ctxId}`;
                header.className = 'sidebar-header';
                header.style =
                    'cursor:pointer; padding:2px 8px; border-left:1px dashed #555; border-bottom:1px solid #333; margin-top:8; display:flex; justify-content:space-between;';
                header.textContent = `${objs[0].domain} | ${objs[0].component} | ${objs[0].semantic_label}`;
                const idSpan = document.createElement('span');
                idSpan.textContent = ctxId;
                idSpan.style = 'opacity:0.6; font-size:0.75rem;';
                header.appendChild(idSpan);
                container.appendChild(header);

                // collapsible dropdown container
                const dropdown = document.createElement('div');
                dropdown.id = `dropdown-${ctxId}`;
                dropdown.style = 'display:none; margin-left:4px;';
                objs.forEach((o, idx) => {
                    const itemContainer = document.createElement('div');
                    itemContainer.id = `sidebar-item-container-${ctxId}-${idx}`;
                    itemContainer.style =
                        'padding:4px 0; cursor:pointer; border-bottom:1px solid #333;';
                    renderObject(o, itemContainer);
                    itemContainer.onclick = () => tweenToNode(ctxId);
                    dropdown.appendChild(itemContainer);
                });
                container.appendChild(dropdown);

                // toggle expand/collapse group
                header.onclick = () => {
                    const isHidden = dropdown.style.display === 'none';
                    dropdown.style.display = isHidden ? 'block' : 'none';
                };
            }
        }

        // Build a BFS “depth” map from the highest‑degree node:
        function computeDepths(nodes, links) {
            const deg = Object.fromEntries(nodes.map(n => [n.id, 0]));
            links.forEach(l => { deg[l.source]++; deg[l.target]++; });
            const root = nodes.reduce((a, b) => deg[a.id] > deg[b.id] ? a : b);
            const depth = { [root.id]: 0 };
            const q = [root.id];
            while (q.length) {
                const u = q.shift();
                links.forEach(l => {
                    const v = l.source === u ? l.target
                        : l.target === u ? l.source
                            : null;
                    if (v != null && depth[v] === undefined) {
                        depth[v] = depth[u] + 1;
                        q.push(v);
                    }
                });
            }
            return depth;
        }
        function runBrainLayout() {
            // 1) gather sim nodes with BFS‐depth & size
            const simNodes = [];
            const depths = {};
            // first compute BFS depths on the fly
            const allNodes = [...nodeMap.keys()].map(id => ({ id }));
            const allLinks = edges.map(e => ({ source: e.source, target: e.target }));
            // build degree map & root
            const deg = Object.fromEntries(allNodes.map(n => [n.id, 0]));
            allLinks.forEach(l => { deg[l.source]++; deg[l.target]++; });
            const root = allNodes.reduce((a, b) => deg[a.id] > deg[b.id] ? a : b);
            // BFS
            const q = [root.id]; depths[root.id] = 0;
            while (q.length) {
                const u = q.shift();
                allLinks.forEach(l => {
                    const v = l.source === u ? l.target : l.target === u ? l.source : null;
                    if (v != null && depths[v] === undefined) {
                        depths[v] = depths[u] + 1; q.push(v);
                    }
                });
            }
            const maxDepth = Math.max(...Object.values(depths), 1);

            // now assemble simNodes with initial random 3D pos
            nodeMap.forEach((entry, id) => {
                const size = JSON.stringify(entry.data).length;
                simNodes.push({
                    id,
                    size,
                    depth: depths[id] || 0,
                    x: (Math.random() - 0.5) * BRAIN_CONFIG.initialSpread,
                    y: (Math.random() - 0.5) * BRAIN_CONFIG.initialSpread,
                    z: (Math.random() - 0.5) * BRAIN_CONFIG.initialSpread
                });
            });

            // 2) assemble simLinks with weight
            const simLinks = edges.map(e => ({
                source: e.source,
                target: e.target,
                weight: nodeMap.get(e.source).data.association_strengths?.[e.target] || 1
            }));

            // 3) custom 3D force simulation via 3 separate 1D forces + XY
            const sim = d3.forceSimulation(simNodes)
                // 2D link on X/Y plane
                .force('link', d3.forceLink(simLinks)
                    .id(d => d.id)
                    .distance(d => 100 / d.weight)
                    .strength(d => Math.min(d.weight * 0.1, 0.5)))
                // 2D repulsion on X/Y
                .force('charge', d3.forceManyBody().strength(d => -Math.sqrt(d.size) * 0.1))
                // pull XY toward center
                .force('center', d3.forceCenter(0, 0))
                // collision in XY
                .force('collision', d3.forceCollide().radius(d => Math.sqrt(d.size) * 0.2));

            // we manually integrate Z as a radial pull toward its depth‐shell
            sim.on('tick', () => {
                simNodes.forEach(d => {
                    // radial Z: each depth level sits at z = depth * depthSpacing
                    d.z += ((d.depth * BRAIN_CONFIG.depthSpacing) - d.z) * 0.1;
                });
            });

            // 4) run to (approx) convergence
            for (let i = 0; i < 300; i++) sim.tick();
            sim.stop();

            // 5) write 3D positions back into your nodeMap
            simNodes.forEach(d => {
                const entry = nodeMap.get(d.id);
                entry.pos.set(d.x, d.y, d.z);
            });
        }
        modeSwitch.addEventListener('click', () => {
            // toggle mode
            brainMode = !brainMode;
            modeSwitch.textContent = brainMode ? 'Brain Mode' : 'Tree Mode';

            if (brainMode) {
                // ─── Brain Mode ───────────────────────────────────────────────────
                runBrainLayout();
                nodeMap.forEach(entry => delete entry.tweenStart);
                updateBrainMatrices();

                // rebuild all edges so they follow your new 3D positions
                updateEdgeMeshes();
            } else {
                // ─── Tree Mode ────────────────────────────────────────────────────
                runForceLayout();

                // in Tree mode edges still follow the force layout
                updateEdgeMeshes();
            }

            // ─── Always OrbitControls ───────────────────────────────────────────
            orbitControls.enabled = true;
            orbitControls.enableZoom = brainMode;      // wheel = zoom in Brain Mode
            orbitControls.enableRotate = !timeMode;      // respect your Time Mode toggle

            // ─── Snap camera onto the selected node, if any ───────────────────
            if (selectedId) {
                const entry = nodeMap.get(selectedId);
                if (entry) {
                    const worldPos = entry.pos.clone();
                    graphGroup.updateMatrixWorld();
                    graphGroup.localToWorld(worldPos);

                    // point the OrbitControls target directly at it
                    orbitControls.target.copy(worldPos);

                    // gently pull the camera toward a frame just above & behind
                    camera.position.lerp(
                        worldPos.clone().add(new THREE.Vector3(0, 100, 100)),
                        0.2
                    );

                    orbitControls.update();
                }
            }

            // ─── Sidebar sync ──────────────────────────────────────────────────
            buildSidebarList(allData);
        });


        let isBuilding = false;
        //////////////////////////////////////////////////////////////////////////
        // BATCHED NODE CREATION
        //////////////////////////////////////////////////////////////////////////

        // break up large inserts into ~500-item chunks so the browser stays responsive
        async function batchAddNodes(objects) {
            isBuilding = true;
            const chunkSize = 500;
            for (let i = 0; i < objects.length; i += chunkSize) {
                const batch = objects.slice(i, i + chunkSize);
                addNodes(batch);
                rebuildEdges();
                // let the browser breathe
                await new Promise(r => requestAnimationFrame(r));
            }
            isBuilding = false;
        }

        // start both counts at zero
        instMesh && (instMesh.count = 0);
        instEdge && (instEdge.count = 0);
        /** called with *only* brand-new parsed objects */
        // ─── UPDATED appendNodesFast ──────────────────────────────────────────
        function appendNodesFast(newObjs, flashWhite = false) {
            // 0️⃣ Filter out duplicates
            const fresh = newObjs.filter(o => !nodeMap.has(o.context_id));
            if (!fresh.length) return;

            // 1️⃣ Ensure mesh exists & has room
            ensureSphereMesh();
            while (freeNodeIx + fresh.length > instMesh.countCapacity) {
                growInstancedMesh(instMesh);
            }

            // 2️⃣ Update palette & connectivity ceiling
            // gather all unique keys from the field we want:
            const keys = [...new Set(
                [...nodeMap.values()].map(n => n.data[COLOR_CONFIG.colorBy])
            )];

            // if you’re in an “append” function, also merge in the incoming batch:
            fresh.forEach(o => {
                cascadeChain(o.context_id);
                const k = o[COLOR_CONFIG.colorBy];
                if (!keys.includes(k)) keys.push(k);
            });

            // now spread them evenly around [0..1)
            hueMapCurrent = Object.fromEntries(
                keys.map((k, i) => [k, i / keys.length])
            );
            maxConnCurrent = Math.max(
                maxConnCurrent,
                ...fresh.map(o =>
                    (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length
                )
            );

            // 3️⃣ Append each newcomer with a Y‐tween
            const clr = new THREE.Color();
            const now = Date.now();
            const groupY = graphGroup.position.y;

            for (const o of fresh) {
                const idx = freeNodeIx++;

                // compute connectivity
                const conn = (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length;

                // final (target) local Y
                const ageMs = now - parseTimestamp(o.timestamp).getTime();
                const globalY = Math.max(
                    LAYOUT_CONFIG.minSphereY,
                    ageMs / LAYOUT_CONFIG.msPerUnit
                );
                const localY = globalY - groupY;

                // scatter XZ
                const rNorm = 1 - (conn / maxConnCurrent);
                const r = rNorm * LAYOUT_CONFIG.maxXZRadius;
                const ang = Math.random() * Math.PI * 2;
                const x = Math.cos(ang) * r, z = Math.sin(ang) * r;

                // record entry with tween metadata
                nodeMap.set(o.context_id, {
                    data: o,
                    // final position
                    pos: new THREE.Vector3(x, localY, z),
                    // initial injection at world Y=0 → localY = –groupY
                    prevPos: new THREE.Vector3(x, -groupY, z),
                    tweenStart: performance.now(),
                    tweenDuration: 800,
                    connectivity: conn,
                    mesh: instMesh,
                    _instanceIndex: idx
                });

                // set initial matrix at prevPos
                instMesh.setMatrixAt(
                    idx,
                    new THREE.Matrix4().makeTranslation(x, -groupY, z)
                );

                // color
                const hue = hueMapCurrent[o.component] ?? 0;
                const sat = 0.5 + 0.5 * (conn / maxConnCurrent);
                if (flashWhite) {
                    instMesh.instanceColor.setXYZ(idx, 1, 1, 1);
                    setTimeout(() => {
                        instMesh.instanceColor.setXYZ(
                            idx,
                            ...clr.setHSL(hue, sat, 0.5).toArray()
                        );
                        instMesh.instanceColor.needsUpdate = true;
                    }, 60);
                } else {
                    instMesh.instanceColor.setXYZ(
                        idx,
                        ...clr.setHSL(hue, sat, 0.5).toArray()
                    );
                }

                console.info('[spawn]', o.context_id, '→ instance', idx);
            }

            // 4️⃣ Commit GPU updates
            instMesh.count = freeNodeIx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // 5️⃣ Rebuild JUST these edges & fire upstream flash
            rebuildEdgesIncremental(fresh.map(o => o.context_id));
            fresh.forEach(o => cascadeChain(o.context_id));
        }

        /** super-fast colour setter used by both add + later filter tweaks */
        function colourNode(idx, obj) {
            const hue = hueMapCurrent[obj.component] ?? 0;
            const sat = 0.6;
            const lgt = 0.8;
            instMesh.instanceColor.setXYZ(idx,
                ...new THREE.Color().setHSL(hue, sat, lgt).toArray());
        }
        function appendEdgesFast(srcObjs) {
            ensureEdgeMesh();

            const mat = new THREE.Matrix4();
            const yAxis = new THREE.Vector3(0, 1, 0);

            for (const o of srcObjs) {
                const entry = nodeMap.get(o.context_id);
                if (!entry) continue;

                const srcPos = entry.pos.clone();
                const cIdx = entry._instanceIndex;
                const refs = Array.isArray(o.references) ? o.references : [];
                const assocs = o.association_strengths
                    ? Object.keys(o.association_strengths)
                    : [];
                const targets = [...refs, ...assocs];

                for (const tgtId of targets) {
                    const tgtEntry = nodeMap.get(tgtId);
                    if (!tgtEntry) continue;

                    const tgtPos = tgtEntry.pos.clone();
                    const dir = new THREE.Vector3().subVectors(tgtPos, srcPos);
                    const len = dir.length();
                    if (len === 0) continue;

                    // if we're about to overflow, grow capacity now
                    if (freeEdgeIx + 1 > instEdge.countCapacity) {
                        growMeshCapacity(instEdge);
                    }

                    // build the edge transform
                    const q = new THREE.Quaternion().setFromUnitVectors(yAxis, dir.normalize());
                    const s = new THREE.Vector3(0.2, len, 0.2);
                    mat.compose(srcPos, q, s);
                    instEdge.setMatrixAt(freeEdgeIx, mat);

                    // copy the source node's color
                    const r = instMesh.instanceColor.getX(cIdx);
                    const g = instMesh.instanceColor.getY(cIdx);
                    const b = instMesh.instanceColor.getZ(cIdx);
                    instEdge.instanceColor.setXYZ(freeEdgeIx, r, g, b);

                    // record edge metadata
                    edges[freeEdgeIx] = {
                        source: o.context_id,
                        target: tgtId,
                        index: freeEdgeIx,
                        weight: (o.association_strengths?.[tgtId] || 1)
                    };

                    freeEdgeIx++;
                }

                // **after** wiring up all the new edges for this node,
                // light up its entire upstream‐chain:
                highlightPathFrom(o.context_id);
            }

            // commit to GPU
            instEdge.count = freeEdgeIx;
            instEdge.instanceMatrix.needsUpdate = true;
            instEdge.instanceColor.needsUpdate = true;
        }




        function pickPosition(o) {
            const conn = (o.references?.length || 0)
                + Object.keys(o.association_strengths || {}).length;
            maxConnCurrent = Math.max(maxConnCurrent, conn);

            // compute age in ms
            const now = Date.now();
            const ageMs = now - parseTimestamp(o.timestamp).getTime();

            // map to world-space Y
            const globalY = (ageMs * LAYOUT_CONFIG.spawnFactor) / LAYOUT_CONFIG.msPerUnit;
            const desiredY = Math.max(LAYOUT_CONFIG.minSphereY, globalY);

            // convert to local by subtracting current drift
            const localY = desiredY - graphGroup.position.y;

            // scatter around XZ
            const rNorm = 1 - (conn / maxConnCurrent);
            const r = rNorm * LAYOUT_CONFIG.maxXZRadius;
            const ang = Math.random() * Math.PI * 2;

            const pos = new THREE.Vector3(
                Math.cos(ang) * r,
                localY,
                Math.sin(ang) * r
            );

            o.pos = pos;
            o.connectivity = conn;
            return pos;
        }

        function ensureSphereMesh() {
            if (instMesh) return;

            const geo = new THREE.SphereGeometry(5, 4, 4);
            instMesh = new THREE.InstancedMesh(
                geo,
                new THREE.MeshLambertMaterial({ vertexColors: true }),
                START_CAP);

            instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const cAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(START_CAP * 3), 3);
            instMesh.geometry.setAttribute('color', cAttr);
            instMesh.instanceColor = cAttr;
            instMesh.countCapacity = START_CAP;
            instMesh.count = 0;

            graphGroup.add(instMesh);
        }

        function ensureEdgeMesh() {
            if (instEdge) return;
            const geo = new THREE.BoxGeometry(0.1, 1, 0.1);
            geo.translate(0, 0.5, 0);

            instEdge = new THREE.InstancedMesh(
                geo,
                new THREE.MeshBasicMaterial({ vertexColors: true }),
                START_CAP * 4
            );
            instEdge.frustumCulled = false;

            // ✏️ allocate the full capacity, and name it `instanceColor`
            const cAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(instEdge.countCapacity * 3), 3
            );
            instEdge.geometry.setAttribute('instanceColor', cAttr);
            instEdge.instanceColor = cAttr;

            graphGroup.add(instEdge);
        }

        /***********************************************************************
         *  growInstancedMesh(oldMesh)
         *  doubles capacity (up to 65535 instances – WebGL1 limit)
         **********************************************************************/
        function growInstancedMesh(old) {
            const newCap = Math.min(old.countCapacity * 2, 0xFFFF);
            const geo = old.geometry.clone();
            const mat = old.material.clone();
            const neo = new THREE.InstancedMesh(geo, mat, newCap);

            /* copy transforms */
            for (let i = 0; i < old.count; i++) {
                old.getMatrixAt(i, neo.matrix);
                neo.setMatrixAt(i, neo.matrix);
            }

            /* copy colours */
            const newColAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(newCap * 3), 3
            );
            neo.geometry.setAttribute('color', newColAttr);
            neo.instanceColor = newColAttr;
            for (let i = 0; i < old.count; i++) {
                newColAttr.setXYZ(
                    i,
                    old.instanceColor.getX(i),
                    old.instanceColor.getY(i),
                    old.instanceColor.getZ(i)
                );
            }

            neo.count = old.count;
            neo.countCapacity = newCap;
            neo.frustumCulled = false;
            neo.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            neo.geometry.boundingSphere = old.geometry.boundingSphere;

            /* replace in the scene */
            graphGroup.remove(old);
            graphGroup.add(neo);
            instMesh = neo;   // global swap
            console.warn('[grow] InstancedMesh capacity →', newCap);
            return neo;
        }
        /* ─────────────────────────────  add / update spheres  ───────────────────────────── */
        function addNodes(objs, flashWhite = false) {

            /* ───────────────────────────────────
             * 0️⃣  Filter out duplicates up-front
             * ─────────────────────────────────── */
            const fresh = objs.filter(o => !nodeMap.has(o.context_id));
            if (!fresh.length) return;

            /* ───────────────────────────────────
             * 1️⃣  Build InstancedMesh (lazy)
             * ─────────────────────────────────── */
            if (!instMesh) {
                const geo = new THREE.SphereGeometry(
                    DISPLAY_CONFIG.sphereRadius,
                    DISPLAY_CONFIG.sphereSegments,
                    DISPLAY_CONFIG.sphereSegments
                );
                instMesh = new THREE.InstancedMesh(
                    geo,
                    new THREE.MeshLambertMaterial({ vertexColors: true }),
                    HARD_MAX_NODES             // ← hard upper bound, never realloc
                );
                instMesh.frustumCulled = false;
                instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const colAttr = new THREE.InstancedBufferAttribute(
                    new Float32Array(HARD_MAX_NODES * 3), 3
                );
                instMesh.geometry.setAttribute('color', colAttr);
                instMesh.instanceColor = colAttr;
                instMesh.geometry.boundingSphere =
                    new THREE.Sphere(new THREE.Vector3(), 1e6);

                graphGroup.add(instMesh);
            }

            /* ───────────────────────────────────
             * 2️⃣  Prune if we’ll overflow
             * ─────────────────────────────────── */
            const overflow = (instMesh.count + fresh.length) - HARD_MAX_NODES;
            if (overflow > 0) pruneOldest(overflow);   // remove N oldest nodes

            /* ───────────────────────────────────
             * 3️⃣  Re-compute palette helpers
             * ─────────────────────────────────── */
            // gather all unique keys from the field we want:
            const keys = [...new Set(
                [...nodeMap.values()].map(n => n.data[COLOR_CONFIG.colorBy])
            )];

            // if you’re in an “append” function, also merge in the incoming batch:
            fresh.forEach(o => {
                const k = o[COLOR_CONFIG.colorBy];
                if (!keys.includes(k)) keys.push(k);
            });

            // now spread them evenly around [0..1)
            hueMapCurrent = Object.fromEntries(
                keys.map((k, i) => [k, i / keys.length])
            );

            /* update connectivity ceiling */
            maxConnCurrent = Math.max(
                maxConnCurrent,
                ...fresh.map(o =>
                    (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length)
            );

            /* colour helper */
            const clr = new THREE.Color();
            const now = Date.now();
            let idx = instMesh.count;     // first free slot

            /* ───────────────────────────────────
             * 4️⃣  Append each newcomer
             * ─────────────────────────────────── */
            for (const o of fresh) {
                /* position */
                const conn = (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length;
                const age = now - parseTimestamp(o.timestamp).getTime();
                const yPos = Math.max(LAYOUT_CONFIG.minSphereY,
                    age / LAYOUT_CONFIG.msPerUnit);
                const r = (1 - conn) * LAYOUT_CONFIG.maxXZRadius;
                const ang = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(Math.cos(ang) * r, yPos, Math.sin(ang) * r);

                instMesh.setMatrixAt(idx, new THREE.Matrix4().setPosition(pos));

                /* palette colour */
                const hue = hueMapCurrent[o.component] ?? 0;
                const sat = 0.5 + 0.5 * (conn / maxConnCurrent);
                instMesh.instanceColor.setXYZ(
                    idx, ...clr.setHSL(hue, sat, 0.5).toArray()
                );
                if (flashWhite) instMesh.instanceColor.setXYZ(idx, 1, 1, 1);

                /* bookkeeping */
                nodeMap.set(o.context_id, {
                    data: o, pos, connectivity: conn,
                    mesh: instMesh, _instanceIndex: idx
                });

                console.info('[spawn]', o.context_id, '→ instance', idx);
                idx++;
            }

            /* commit GPU updates */
            instMesh.count = idx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            rebuildEdgesIncremental(fresh.map(o => o.context_id)); // add edges from newcomers
        }

        /*********************************************************************
         *  pruneOldest(n)
         *  — removes the n oldest nodes (smallest timestamp) from scene & state
         *********************************************************************/
        function pruneOldest(n) {
            if (n <= 0) return;

            /* pick candidates: sort by original timestamp ASC */
            const victims = [...nodeMap.values()]
                .sort((a, b) =>
                    parseTimestamp(a.data.timestamp) - parseTimestamp(b.data.timestamp))
                .slice(0, n);

            for (const victim of victims) {
                const rmIdx = victim._instanceIndex;

                /* 1) remove from nodeMap */
                nodeMap.delete(victim.data.context_id);

                /* 2) compact InstancedMesh by moving last instance into the hole */
                const lastIdx = instMesh.count - 1;
                if (rmIdx !== lastIdx) {
                    // copy matrix & colour
                    instMesh.getMatrixAt(lastIdx, _tmpMat4);
                    instMesh.setMatrixAt(rmIdx, _tmpMat4);

                    instMesh.instanceColor.setXYZ(
                        rmIdx,
                        instMesh.instanceColor.getX(lastIdx),
                        instMesh.instanceColor.getY(lastIdx),
                        instMesh.instanceColor.getZ(lastIdx)
                    );

                    // update bookkeeping of the node that was moved
                    const movedNode = [...nodeMap.values()]
                        .find(n => n._instanceIndex === lastIdx);
                    if (movedNode) movedNode._instanceIndex = rmIdx;
                }
                instMesh.count--;  // shrink by one
            }

            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            /* remove any edges that referenced dead nodes and rebuild */
            edges = edges.filter(e =>
                nodeMap.has(e.source) && nodeMap.has(e.target)
            );
            rebuildEdges();   // full rebuild is simple & fast enough at this size
        }

        /* temp scratch matrix for pruneOldest() */
        const _tmpMat4 = new THREE.Matrix4();


        function rebuildEdgesIncremental(srcIds) {
            /* make sure the InstancedMesh and colour buffer exist */
            initEdges();
            const colAttr = instEdge.instanceColor;

            let ei = instEdge.count || 0;              // append after existing edges
            const tmpMat = new THREE.Matrix4();
            const axisY = new THREE.Vector3(0, 1, 0);

            srcIds.forEach(srcId => {
                const n = nodeMap.get(srcId);
                if (!n) return;

                /* strongest weight per target */
                const links = new Map();
                (n.data.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(n.data.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w)));

                links.forEach((w, tgtId) => {
                    const tgt = nodeMap.get(tgtId);
                    if (!tgt || ei >= MAX_EDGES) return;

                    /* direction & length */
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const len = dir.length();
                    if (!len) return;                       // avoid zero-length edges

                    const quat = new THREE.Quaternion().setFromUnitVectors(axisY, dir.normalize());

                    /* variable thickness */
                    const t = edgeThickness(w);

                    /* compose transform and write instance matrix */
                    tmpMat.compose(n.pos, quat, new THREE.Vector3(t, len, t));
                    instEdge.setMatrixAt(ei, tmpMat);

                    /* colour = RGB of the source node */
                    const srcIdx = n._instanceIndex;
                    colAttr.setXYZ(
                        ei,
                        instMesh.instanceColor.getX(srcIdx),
                        instMesh.instanceColor.getY(srcIdx),
                        instMesh.instanceColor.getZ(srcIdx)
                    );

                    /* edge metadata */
                    edges[ei] = { source: srcId, target: tgtId, index: ei, weight: w };

                    ei++;
                });
            });

            /* commit to GPU */
            instEdge.frustumCulled = false;       // ← ADD THIS HERE, too
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }



        /* ─── append ONLY the brand-new edges coming from newObjs ────────────── */
        function addEdges(newObjs) {
            initEdges();                              // InstancedMesh already set up

            const colAttr = instEdge.instanceColor;   // colour buffer (no alpha logic)
            let idx = instEdge.count;           // first free instance slot

            for (const obj of newObjs) {
                const srcNode = nodeMap.get(obj.context_id);
                if (!srcNode) continue;

                /* pick the strongest link weight per target */
                const links = new Map();
                (obj.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(obj.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w)));

                for (const [tgtId, w] of links) {
                    const tgtNode = nodeMap.get(tgtId);
                    if (!tgtNode || idx >= MAX_EDGES) continue;

                    /* build transform (stretch unit box to full edge length) */
                    const dir = new THREE.Vector3().subVectors(tgtNode.pos, srcNode.pos);
                    const len = dir.length();
                    if (!len) continue;

                    const quat = new THREE.Quaternion()
                        .setFromUnitVectors(new THREE.Vector3(0, 1, 0),
                            dir.normalize());

                    instEdge.setMatrixAt(
                        idx,
                        new THREE.Matrix4().compose(
                            srcNode.pos,
                            quat,
                            new THREE.Vector3(edgeThickness(w), len, edgeThickness(w))
                        )
                    );

                    /* starting colour = mid-grey */
                    colAttr.setXYZ(idx, BASE_EDGE_GREY, BASE_EDGE_GREY, BASE_EDGE_GREY);

                    /* metadata for hover / cascade logic */
                    edges[idx] = { source: obj.context_id, target: tgtId, index: idx, weight: w };

                    idx++;
                }
            }

            /* commit to GPU */
            instEdge.count = idx;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }



        // recompute max connectivity once per batch
        function computeMaxConnectivity() {
            return Math.max(
                1,
                ...[...nodeMap.values()].map(n => n.connectivity)
            );
        }
        /* ─── INITIAL FULL LOAD  (runs once) ────────────────────────────────── */
        async function loadGraph() {
            const url = getContextFileUrl(false);
            console.log('[loadGraph] initial load from', url);

            clearScene();                 // wipe scene & JS-side state
            remoteSize = 0;               // reset processed-byte counter

            /* 1️⃣  grab the whole file (no cache-buster, so HEAD/RANGE work later) */
            const fullRes = await fetch(url, { cache: 'no-store' });
            const fullText = await fullRes.text();

            /* 2️⃣  record EXACT byte length reported by the server */
            const lenHdr = fullRes.headers.get('Content-Length');
            remoteSize = lenHdr ? Number(lenHdr)                    // preferred
                : new TextEncoder().encode(fullText).length;

            /* 3️⃣  parse every JSON-line */
            const objs = fullText
                .trim()                 // safe to trim for parsing
                .split(/\r?\n/)
                .filter(Boolean)
                .map(JSON.parse);

            objs.forEach(o => seenIds.add(o.context_id));
            await batchAddNodes(objs);   // spheres
            addEdges(objs);              // edges

            allData = [...nodeMap.values()].map(n => n.data);

            // after loading allData for the first time:
            const NODE_CAP = allData.length * 1.2;  // a bit of headroom
            const nodeGeom = new THREE.SphereGeometry(1, 8, 8);
            const nodeMat = new THREE.MeshStandardMaterial({ vertexColors: true });
            const nodesInst = new THREE.InstancedMesh(nodeGeom, nodeMat, NODE_CAP);

            // per‑instance data attributes:
            const posAttr = new THREE.InstancedBufferAttribute(new Float32Array(NODE_CAP * 3), 3);
            const scaleAttr = new THREE.InstancedBufferAttribute(new Float32Array(NODE_CAP), 1);
            const colAttr = new THREE.InstancedBufferAttribute(new Float32Array(NODE_CAP * 3), 3);

            nodesInst.geometry.setAttribute('instancePosition', posAttr);
            nodesInst.geometry.setAttribute('instanceScale', scaleAttr);
            nodesInst.geometry.setAttribute('instanceColor', colAttr);

            scene.add(nodesInst);

            // initial population
            populateDomainFilter(allData);
            populateComponentFilter(allData, '');
            populateSemanticFilter(allData, '', '');

            applyFilters();
            prevLineCount = objs.length;
            initialLoadDone = true;

            // set free-indices so fast appends pick up where full load left off
            freeNodeIx = instMesh.count;
            freeEdgeIx = instEdge?.count || 0;
        }

        // Find your existing loadGraph override at the bottom of your module:
        const oldLoadGraph = loadGraph;
        loadGraph = async function (...args) {
            await oldLoadGraph(...args);

            if (brainMode) {
                runBrainLayout();
                updateBrainMatrices();
            } else {
                runForceLayout();
            }

            updateEdgeMeshes();
            buildSidebarList(allData);
        };


        async function grabTailChunk(url,
            maxBytes = 128 * 1024,
            wantLines = 300) {

            /* try a single Range fetch first */
            try {
                const res = await fetch(url, {
                    headers: { Range: `bytes=-${maxBytes}` },
                    cache: 'no-store'
                });
                if (res.status === 206) {                     // honoured → trivial
                    const txt = await res.text();
                    return txt.trim().split(/\r?\n/).slice(-wantLines);
                }
                /* else fall through – some servers just return 200 */
            } catch { /* ignore → streaming fallback */ }

            /* streaming fallback (no Range support, no C-L checks → no mismatch) */
            const bust = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();
            const res = await fetch(bust, { cache: 'no-store' });
            const rdr = res.body?.getReader?.();

            if (!rdr) {                             // no streams? read whole file
                const txt = await res.text();
                return txt.trim().split(/\r?\n/).slice(-wantLines);
            }

            const dec = new TextDecoder();
            let buf = '';
            const lines = [];

            while (true) {
                const { value, done } = await rdr.read();
                if (done) break;

                buf += dec.decode(value, { stream: true });
                const parts = buf.split(/\r?\n/);
                buf = parts.pop();
                lines.push(...parts);

                if (lines.length >= wantLines + 50) {   // small margin, then stop
                    rdr.cancel().catch(() => { });
                    break;
                }
            }
            buf += dec.decode();
            if (buf) lines.push(buf);

            return lines.filter(Boolean).slice(-wantLines);
        }


        async function grabTailLines(url, wantLines = 50, offset = 0) {

            // always bust cache so browsers never reuse a half-served response
            const bust = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();

            try {
                const res = await fetch(bust, {
                    headers: { Range: `bytes=${offset}-` },   // hope for 206
                    cache: 'no-store'
                });

                /* ===== CASE 1 – server honours Range (206) ======================= */
                if (res.status === 206) {
                    const txt = await res.text();
                    const lines = txt.trim().split(/\r?\n/).filter(Boolean).slice(-wantLines);
                    const newOffset = offset + new TextEncoder().encode(txt).length;
                    return { lines, newOffset };
                }

                /* ===== CASE 2 – server ignores Range (200) – stream & abort ====== */
                const reader = res.body?.getReader?.();

                // No stream available (older server) – read the whole thing
                if (!reader) {
                    const txt = await res.text();
                    const all = txt.trim().split(/\r?\n/).filter(Boolean);
                    const size = new TextEncoder().encode(txt).length;
                    return { lines: all.slice(-wantLines), newOffset: size };
                }

                const dec = new TextDecoder();
                let buffer = '';
                const lines = [];
                let bytes = 0;               // track how many bytes we really read

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    bytes += value.byteLength;
                    buffer += dec.decode(value, { stream: true });
                    const parts = buffer.split(/\r?\n/);
                    buffer = parts.pop();
                    lines.push(...parts);

                    if (lines.length >= wantLines + 5) {      // small margin
                        reader.cancel().catch(() => { });
                        break;
                    }
                }
                buffer += dec.decode();
                if (buffer) { lines.push(buffer); bytes += buffer.length; }

                return {
                    lines: lines.filter(Boolean).slice(-wantLines),
                    newOffset: offset + bytes          // advance by what we actually read
                };

            } catch (err) {
                console.warn('[grabTailLines] request failed:', err);
                return { lines: [], newOffset: offset };       // graceful degradation
            }
        }
        function cascadeUpstream(originId) {
            if (!edges.length || !instEdge) return;

            const visited = new Set([originId]);
            const queue = [{ id: originId, depth: 0 }];
            const MAX_D = DISPLAY_CONFIG.maxChainDepth ?? 10;         // fallback ≡ 3
            const DELAY = DISPLAY_CONFIG.chainDelay * 200;        // ms per hop

            while (queue.length) {
                const { id, depth } = queue.shift();
                if (depth >= MAX_D) continue;

                const n = nodeMap.get(id);
                if (!n) continue;

                /* gather all upstream neighbours (references + assoc_strengths keys) */
                const nbrIds = new Set([
                    ...(n.data.references || []),
                    ...Object.keys(n.data.association_strengths || {})
                ]);

                for (const nbrId of nbrIds) {
                    if (!nodeMap.has(nbrId) || visited.has(nbrId)) continue;

                    /* find the edge object that connects id ↔︎ nbrId */
                    const e = edges.find(ed =>
                        (ed.source === id && ed.target === nbrId) ||
                        (ed.source === nbrId && ed.target === id)
                    );
                    if (!e) continue;           // edge might not exist (filtered out)

                    /* schedule a pulse for this edge only */
                    const baseAlpha = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);
                    setTimeout(() => pulseEdge(e.index, baseAlpha), DELAY * depth);

                    /* enqueue neighbour for the next shell */
                    queue.push({ id: nbrId, depth: depth + 1 });
                    visited.add(nbrId);
                }
            }
        }

        async function pollForNew() {
            const url = getContextFileUrl(true);
            console.groupCollapsed(`[poll] ${new Date().toISOString()}`);

            // ① HEAD → check length / etag
            let head;
            try {
                head = await fetch(url, { method: "HEAD", cache: "no-store" });
            } catch (e) {
                console.warn("HEAD failed", e);
                console.groupEnd();
                return;
            }
            const size = Number(head.headers.get("Content-Length") || 0);
            const etag = head.headers.get("ETag") || "";

            // no change?
            if (size === lastSize && etag === lastETag) {
                console.debug("no change – skipping GET");
                console.groupEnd();
                return;
            }
            // file was rotated (shrunk)?
            if (size < lastSize) lastContextId = null;

            // ② GET the tail
            const rangeStart = Math.max(0, size - LAST_KB * 1024);
            let res;
            try {
                res = await fetch(url, {
                    headers: { Range: `bytes=${rangeStart}-` },
                    cache: "no-store"
                });
            } catch (e) {
                console.warn("GET failed", e);
                console.groupEnd();
                return;
            }

            const rangeHonoured = res.status === 206;
            console.debug(`GET ${res.status} (Range honoured? ${rangeHonoured})`);

            let chunk = "";
            if (rangeHonoured) {
                chunk = await res.text();
            } else if (res.body && res.body.getReader) {
                // fallback streaming until enough lines
                const rdr = res.body.getReader();
                const dec = new TextDecoder();
                let buf = "", lines = [], seen = lastContextId === null;
                try {
                    while (true) {
                        const { value, done } = await rdr.read();
                        if (done) break;
                        buf += dec.decode(value, { stream: true });
                        const parts = buf.split(/\r?\n/);
                        buf = parts.pop();
                        for (const ln of parts) {
                            if (!ln) continue;
                            if (!seen) {
                                if (lastContextId === null || ln.includes(lastContextId)) {
                                    seen = true;
                                }
                                continue;
                            }
                            lines.push(ln);
                            if (lines.length >= WANT_LINES) {
                                await rdr.cancel();
                                break;
                            }
                        }
                        if (lines.length >= WANT_LINES) break;
                    }
                    if (buf && seen) lines.push(buf);
                    chunk = lines.join("\n");
                } catch (err) {
                    console.warn("stream error", err);
                    try { await rdr.cancel(); } catch { }
                }
            } else {
                console.warn("Stream API not available → bailing");
                console.groupEnd();
                return;
            }

            // ③ parse & dedupe
            const fresh = [];
            chunk.split(/\r?\n/).forEach(ln => {
                if (!ln.trim()) return;
                try {
                    const o = JSON.parse(ln);
                    if (o.context_id && !seenIds.has(o.context_id)) {
                        seenIds.add(o.context_id);
                        fresh.push(o);
                    }
                } catch { }
            });

            console.debug("fresh objects:", fresh.length);
            if (fresh.length) {
                // update 3D graph
                appendNodesFast(fresh, true);
                appendEdgesFast(fresh);

                // bump sentinel
                lastContextId = fresh[fresh.length - 1].context_id;

                // merge & rebuild sidebar
                allData.push(...fresh);
                buildSidebarList(allData);

                // auto-scroll if allowed
                if (autoScrollEnabled) {
                    sidebar.scrollTop = sidebar.scrollHeight;
                }

                // re-apply filters so new nodes get correct coloring
                applyFilters();
            }

            // ④ remember state
            lastSize = size;
            lastETag = etag;
            console.groupEnd();
        }


        // ─── BUILD SCENE ──────────────────────────────────────────────────
        function buildScene(objects) {
            // sort by timestamp (newest first)
            objects.sort((a, b) =>
                parseTimestamp(b.timestamp) - parseTimestamp(a.timestamp)
            );

            const now = Date.now();
            nodeMap.clear();

            // index + compute connectivity
            objects.forEach(o => {
                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;
                nodeMap.set(o.context_id, {
                    data: o,
                    mesh: null,
                    pos: new THREE.Vector3(),
                    connectivity: conn
                });
            });

            // layout: Y = age, XZ scatter by connectivity
            const maxConn = Math.max(...[...nodeMap.values()].map(n => n.connectivity), 1);
            nodeMap.forEach(n => {
                const age = now - parseTimestamp(n.data.timestamp).getTime();
                n.pos.y = Math.max(LAYOUT_CONFIG.minSphereY, age / LAYOUT_CONFIG.msPerUnit);
                const norm = 1 - (n.connectivity / maxConn);
                const r = norm * LAYOUT_CONFIG.maxXZRadius;
                const a = Math.random() * Math.PI * 2;
                n.pos.x = Math.cos(a) * r;
                n.pos.z = Math.sin(a) * r;
            });


            // 1) At initialization (once):

            {
                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 1, 0)
                ]);

                instEdge = new THREE.InstancedMesh(lineGeo, edgeMaterial, MAX_EDGES);
                instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instEdge.geometry.setAttribute(
                    'alpha',
                    new THREE.InstancedBufferAttribute(new Float32Array(MAX_EDGES), 1)
                        .setUsage(THREE.DynamicDrawUsage)
                );

                graphGroup.add(instEdge);
            }


            let ei = 0;
            nodeMap.forEach((n, id) => {
                // gather all connections
                const conns = new Map();
                (n.data.references || []).forEach(rid => conns.set(rid, 1));
                Object.entries(n.data.association_strengths || {}).forEach(([rid, w]) =>
                    conns.set(rid, Math.max(conns.get(rid) || 0, w))
                );

                conns.forEach((w, oid) => {
                    const tgt = nodeMap.get(oid);
                    if (!tgt) return;

                    // compute direction vector and length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const length = dir.length();
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        dir.normalize()
                    );

                    // build the instance transform
                    const matrix = new THREE.Matrix4().compose(
                        n.pos,                         // translation
                        quat,                          // orientation
                        new THREE.Vector3(1, length, 1) // scale (stretch line to length)
                    );

                    instEdge.setMatrixAt(ei, matrix);
                    instEdge.geometry.attributes.alpha.setX(
                        ei,
                        DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, w)
                    );
                    ei++;
                });
            });

            // finalize instance count and upload updates
            instEdge.count = ei;
            instEdge.geometry.attributes.alpha.needsUpdate = true;

            // refresh UI filters if needed…
            populateTypeFilter(objects);
            applyFilters();
        }
        // ─── INITIALIZE ──────────────────────────────────────────────────
        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        domainSel.addEventListener('change', () => {
            populateComponentFilter(allData, domainSel.value);
            populateSemanticFilter(allData, domainSel.value, componentSel.value);
            applyFilters();
        });

        componentSel.addEventListener('change', () => {
            populateSemanticFilter(allData, domainSel.value, componentSel.value);
            applyFilters();
        });

        semanticSel.addEventListener('change', () => {
            applyFilters();
        });
        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            orbitControls.enableRotate = !timeMode;
        });//////////////////////////////////////////////////////////////////////////
// THREE.JS SETUP
//////////////////////////////////////////////////////////////////////////
const scene = new THREE.Scene();
scene.background = null;                          // let CSS paint the black

// ─── CAMERA ──────────────────────────────────────────────────────────
const camera = new THREE.PerspectiveCamera(
    85,
    window.innerWidth / window.innerHeight,
    0.1,
    2e6
);
camera.position.set(0, -400, 0);
camera.lookAt(0, 0, 0);

// ─── RENDERER ────────────────────────────────────────────────────────
const DPR = Math.min(window.devicePixelRatio, 1.25);   // clamp high‑DPI
const renderer = new THREE.WebGLRenderer({
    antialias       : true,                     // drop MSAA → big win

    powerPreference : 'high-performance'
});
renderer.setPixelRatio(DPR);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.sortObjects = false;                    // skip depth‑sort
document.body.appendChild(renderer.domElement);

let prevTime = performance.now();

// maximum turn rate (rad/s) and damping
const KEY_MAX_SPEED = Math.PI;
const KEY_DAMPING   = 5;   // higher = snappier, lower = floatier

// actual & target angular velocities
let yawVelocity = 0,
    pitchVelocity = 0,
    yawTarget = 0,
    pitchTarget = 0;

// — for head‑pose tracking —
let video, faceLandmarker, handLandmarker;
const poseTransform = new THREE.Object3D();
const prevEuler     = new THREE.Euler();

// — for hand‑landmark spheres/lines —
const fingerGroup = new THREE.Group();
scene.add(fingerGroup);

// — orbitCamera helper (yaw, pitch, roll deltas) —
function orbitCamera(dY, dP, dR) {
    const T = orbitControls.target;
    const O = camera.position.clone().sub(T);

    // yaw around world‑up
    O.applyQuaternion(
        new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), dY)
    );

    // pitch around camera‑right
    const R = new THREE.Vector3().crossVectors(camera.up, O).normalize();
    O.applyQuaternion(
        new THREE.Quaternion().setFromAxisAngle(R, dP)
    );

    // roll around view direction
    const F = O.clone().normalize();
    camera.up.applyQuaternion(
        new THREE.Quaternion().setFromAxisAngle(F, dR)
    );

    camera.position.copy(T).add(O);
    camera.lookAt(T);
}

        // — initialize webcam + MediaPipe models —
        async function initVision() {
            // hidden video
            video = document.createElement('video');
            video.style.display = 'none';
            document.body.appendChild(video);

            // start camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' }
                });
                video.srcObject = stream;
                await video.play();
            } catch (err) {
                console.warn('Camera failed:', err);
                return;
            }

            // load the MediaPipe fileset
            const fileset = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
                baseOptions: {
                    modelAssetPath:
                        'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                outputFaceBlendshapes: true,
                outputFacialTransformationMatrixes: true,
                runningMode: 'VIDEO',
                numFaces: 1
            });

            handLandmarker = await HandLandmarker.createFromOptions(fileset, {
                baseOptions: {
                    modelAssetPath:
                        'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                    delegate: 'GPU'
                },
                outputHandLandmarks: true,
                runningMode: 'VIDEO',
                numHands: 2
            });
        }

        // kick it off
        initVision();

        // ─── CONTROLS ────────────────────────────────────────────────────────
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.enableZoom = false;
        orbitControls.enablePan = false;
        orbitControls.rotateSpeed = -orbitControls.rotateSpeed;
        orbitControls.minPolarAngle = 0;
        orbitControls.maxPolarAngle = Math.PI;

        const flyControls = new FlyControls(camera, renderer.domElement);
        flyControls.movementSpeed = 100;      // world units per second
        flyControls.rollSpeed = Math.PI;  // radians per second
        flyControls.dragToLook = true;     // click+drag to control pitch/yaw
        flyControls.autoForward = false;    // only move when you press keys
        flyControls.enabled = false;    // start disabled
        orbitControls.enableDamping = true;

        // lock out zoom & pan
        orbitControls.enableZoom = false;
        orbitControls.enablePan = false;

        // (optional) flip horizontal drag direction
        orbitControls.rotateSpeed = -orbitControls.rotateSpeed;

        // full pitch range so you can sweep “up” and “down” around the Y-axis baseline
        //orbitControls.minPolarAngle = 0;       // look all the way “through” to –Y
        //orbitControls.maxPolarAngle = Math.PI; // back down to +Y

        // full 360° yaw
        orbitControls.minAzimuthAngle = -Infinity;
        orbitControls.maxAzimuthAngle = Infinity;

        // one-time sync
        orbitControls.update();


        window.addEventListener('keydown', e => {
            switch (e.code) {
                case 'ArrowLeft': yawTarget = KEY_MAX_SPEED; break;
                case 'ArrowRight': yawTarget = -KEY_MAX_SPEED; break;
                case 'ArrowUp': pitchTarget = KEY_MAX_SPEED; break;
                case 'ArrowDown': pitchTarget = -KEY_MAX_SPEED; break;
            }
        });
        window.addEventListener('keyup', e => {
            switch (e.code) {
                case 'ArrowLeft':
                case 'ArrowRight': yawTarget = 0; break;
                case 'ArrowUp':
                case 'ArrowDown': pitchTarget = 0; break;
            }
        });

        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        function onWheel(e) {
            e.preventDefault();

            if (brainMode) {
                // in Brain‑Mode: “dolly” by scaling the camera‑to‑target vector
                const zoomFactor = 1 + e.deltaY * 0.001;  // tweak sensitivity here
                if (zoomFactor > 0) {
                    // vector from target → camera
                    const dir = camera.position.clone().sub(orbitControls.target);
                    // scale it and re‑position camera
                    dir.multiplyScalar(zoomFactor);
                    camera.position.copy(orbitControls.target.clone().add(dir));
                    orbitControls.update();
                }
                return;
            }

            // ─── Time-mode scroll fallback ──────────────────────────────────
            const baseDelta = e.deltaY * SCROLL_ACCEL;
            const dir = Math.sign(baseDelta);
            const now = Date.now();

            if (dir === lastWheelDir && (now - lastWheelTime) < 200) {
                scrollBoost = Math.min(BOOST_MAX, scrollBoost + BOOST_INCREMENT);
            } else {
                scrollBoost = 1;
            }
            lastWheelDir = dir;
            lastWheelTime = now;

            scrollVelocity += dir * Math.pow(Math.abs(baseDelta), 1.2) * scrollBoost;
        }





        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 5));
        const keyLight = new THREE.DirectionalLight(0xffffff, 5);
        keyLight.position.set(0, 0, 0);
        scene.add(keyLight);

        const graphGroup = new THREE.Group();
        scene.add(graphGroup);

        //////////////////////////////////////////////////////////////////////////
        // EDGE INSTANCED MESH SETUP (skinny box)
        //////////////////////////////////////////////////////////////////////////
        const MAX_EDGES = 20_000;
        /* ─── EDGE INSTANCED-MESH  (creates per-instance alpha attr + custom shader) ── */
        /* ─── EDGE INSTANCED-MESH  (base brightness = 0.1) ───────────────────── */
        /* 1️⃣  create (once) the InstancedMesh + per-edge alpha */
        // ───────────────────────────────────────────────────────────────────
        // ONE-TIME instanced-line mesh with per-instance colours
        // ───────────────────────────────────────────────────────────────────
        // ─── one-time InstancedMesh for all edges ──────────────────────────────
        function initEdges() {
            if (instEdge) return;

            // 1) build a thin box (pivot at bottom) for each edge
            const geo = new THREE.BoxGeometry(0.1, 1, 0.1);
            geo.translate(0, 0.5, 0); // move origin to base

            // 2) per-edge material
            const mat = new THREE.MeshBasicMaterial({
                vertexColors: true,    // ← look for a "color" attribute
                transparent: true,     // ← allow fade/alpha later
                depthWrite: false
            });

            // 3) create the InstancedMesh
            instEdge = new THREE.InstancedMesh(geo, mat, MAX_EDGES);
            instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            // 4) allocate & seed a "color" attribute (r,g,b per instance)
            const base = BASE_EDGE_GREY;
            const cols = new Float32Array(MAX_EDGES * 3).fill(base);
            const cAttr = new THREE.InstancedBufferAttribute(cols, 3)
                .setUsage(THREE.DynamicDrawUsage);

            // 5) attach it *as* the "color" attribute so the material picks it up
            instEdge.geometry.setAttribute('color', cAttr);
            // still convenient to reference it as `instEdge.instanceColor` in your code
            instEdge.instanceColor = cAttr;

            graphGroup.add(instEdge);
        }

        // ─── Ensure your per‐edge alpha attribute exists ──────────
        function ensureEdgeAlphaAttr() {
            if (!instEdge) return;                              // mesh not ready
            if (instEdge.geometry.attributes.alpha) return;     // already installed

            const alphaArr = new Float32Array(MAX_EDGES)
                .fill(DISPLAY_CONFIG.lineBaseOpacity);
            const aAttr = new THREE.InstancedBufferAttribute(alphaArr, 1)
                .setUsage(THREE.DynamicDrawUsage);

            instEdge.geometry.setAttribute('alpha', aAttr);
        }

        // ─── Full rebuild of every edge ─────────────────────────
        function rebuildEdges() {
            initEdges();               // make sure instEdge exists
            ensureEdgeAlphaAttr();     // install alpha buffer if needed

            const colAttr = instEdge.instanceColor;
            edges.length = 0;
            let ei = 0;

            nodeMap.forEach((src, srcId) => {
                // gather strongest‐weight per target
                const links = new Map();
                (src.data.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(src.data.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w))
                    );

                links.forEach((w, tgtId) => {
                    const tgt = nodeMap.get(tgtId);
                    if (!tgt || ei >= MAX_EDGES) return;

                    // direction & length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, src.pos);
                    const len = dir.length();
                    if (!len) return;

                    // orientation quaternion
                    const quat = new THREE.Quaternion()
                        .setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());

                    // thickness based on weight
                    const t = edgeThickness(w);

                    // write transform
                    instEdge.setMatrixAt(
                        ei,
                        new THREE.Matrix4().compose(
                            src.pos,
                            quat,
                            new THREE.Vector3(t, len, t)
                        )
                    );

                    // copy colour from source node
                    const srcIdx = src._instanceIndex;
                    const r = instMesh.instanceColor.getX(srcIdx);
                    const g = instMesh.instanceColor.getY(srcIdx);
                    const b = instMesh.instanceColor.getZ(srcIdx);
                    colAttr.setXYZ(ei, r, g, b);

                    edges.push({ source: srcId, target: tgtId, index: ei, weight: w });
                    ei++;
                });
            });

            // upload
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }


        //////////////////////////////////////////////////////////////////////////
        // USAGE—call these once at startup, then whenever nodeMap changes:
        //////////////////////////////////////////////////////////////////////////
        initEdges();
        if (!instEdge.geometry.attributes.alpha) {
            const base = DISPLAY_CONFIG.lineBaseOpacity;
            const aAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(MAX_EDGES).fill(base), 1
            );
            instEdge.geometry.setAttribute('alpha', aAttr);
        }



        //////////////////////////////////////////////////////////////////////
        // HELPERS
        //////////////////////////////////////////////////////////////////////
        function parseTimestamp(ts) {
            const y = +ts.slice(0, 4), m = +ts.slice(4, 6) - 1, d = +ts.slice(6, 8),
                hh = +ts.slice(9, 11), mm = +ts.slice(11, 13), ss = +ts.slice(13, 15);
            return new Date(Date.UTC(y, m, d, hh, mm, ss));
        }
        function unixNow() { return Date.now(); }
        function edgeThickness(w) {
            const MIN = 1;   // thinnest possible edge
            const MAX = 2;   // thickest possible edge
            /* clamp & normalise:   0 → MIN,   1 or above → MAX  */
            w = Math.min(Math.max(w, 0.5), 2);
            return MIN + (MAX - MIN) * w;
        }
        function clearScene() {
            // ── remove all meshes (nodes & edges) under graphGroup
            graphGroup.children.slice().forEach(child => {
                graphGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            // reset references to instanced meshes
            instMesh = null;
            instEdge = null;

            // reset group transform so next load starts at y = 0
            graphGroup.position.set(0, 0, 0);
            yScrollOffset = 0;
            lastDriftT = Date.now();

            // ── wipe JS-side state
            nodeMap.clear();
            edges.length = 0;
            pickableMeshes.length = 0;
            hovered = hoveredIdx = selectedId = null;
            prevCount = 0;

            // ── clear UI
            selPane.textContent = '// Hover or click a node…';
            detailPanel.innerHTML = '';
        }


        //////////////////////////////////////////////////////////////////////
        // FILTERS
        //////////////////////////////////////////////////////////////////////
        function populateDomainFilter(data) {
            const domains = [...new Set(data.map(o => o.domain))].sort();
            domainSel.innerHTML =
                '<option value="">All domains</option>' +
                domains.map(d => `<option value="${d}">${d}</option>`).join('');
        }

        function populateComponentFilter(data, domain) {
            const comps = [...new Set(
                data
                    .filter(o => !domain || o.domain === domain)
                    .map(o => o.component)
            )].sort();
            componentSel.innerHTML =
                '<option value="">All components</option>' +
                comps.map(c => `<option value="${c}">${c}</option>`).join('');
        }

        function populateSemanticFilter(data, domain, component) {
            const labels = [...new Set(
                data
                    .filter(o =>
                        (!domain || o.domain === domain) &&
                        (!component || o.component === component)
                    )
                    .map(o => o.semantic_label)     // adjust if your field is named differently
                    .filter(l => !!l)
            )].sort();
            semanticSel.innerHTML =
                '<option value="">All labels</option>' +
                labels.map(l => `<option value="${l}">${l}</option>`).join('');
        }

        function applyFilters() {
            const now = unixNow();
            const ageMax = ({
                h1: 3600e3, d1: 86400e3, w1: 86400e3 * 7,
                m1: 86400e3 * 30
            }[ageSel.value]) || 0;

            // new cascading filters
            const selDomain = domainSel.value;
            const selComponent = componentSel.value;
            const selSemantic = semanticSel.value;

            const color = new THREE.Color();

            /* 1️⃣  NODES */
            let writeIdx = 0;
            const liveIds = new Set();
            const selectedIds = new Set();

            nodeMap.forEach((n, ctxId) => {
                const o = n.data;

                // age filter
                if (ageMax) {
                    const age = now - parseTimestamp(o.timestamp).getTime();
                    if (age > ageMax) return;
                }
                liveIds.add(ctxId);

                // domain filter
                if (selDomain && o.domain !== selDomain) return;

                // component filter
                if (selComponent && o.component !== selComponent) return;

                // semantic_label filter
                if (selSemantic && o.semantic_label !== selSemantic) return;

                selectedIds.add(ctxId);

                // position
                instMesh.setMatrixAt(writeIdx,
                    new THREE.Matrix4().setPosition(n.pos));

                // colour
                if (ctxId === selectedId) {
                    // clicked – stay white
                    instMesh.instanceColor.setXYZ(writeIdx, 1, 1, 1);
                } else if (!selDomain && !selComponent && !selSemantic) {
                    // only age filter active
                    const hue = hueMapCurrent[o.component] || 0;
                    const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                    instMesh.instanceColor.setXYZ(
                        writeIdx, ...color.setHSL(hue, sat, 0.5).toArray());
                } else {
                    // cascading filters active
                    if (selectedIds.has(ctxId)) {
                        // passes all selected filters
                        instMesh.instanceColor.setXYZ(writeIdx, 1, 1, 1);
                    } else {
                        // filtered out → dim
                        const hue = hueMapCurrent[o.component] || 0;
                        const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                        instMesh.instanceColor.setXYZ(
                            writeIdx, ...color.setHSL(hue, sat, 0.25).toArray());
                    }
                }

                n._instanceIndex = writeIdx;
                writeIdx++;
            });

            instMesh.count = writeIdx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            /* 2️⃣  EDGES */
            if (!instEdge) return;
            ensureEdgeAlphaAttr();
            const aAttr = instEdge.geometry.attributes.alpha;
            const cAttr = instEdge.instanceColor;

            edges.forEach(e => {
                const live = liveIds.has(e.source) && liveIds.has(e.target);
                aAttr.setX(e.index, live ? 1 : 0);
                if (!live) return;

                const srcNode = nodeMap.get(e.source);
                const srcIdx = srcNode._instanceIndex;
                cAttr.setXYZ(
                    e.index,
                    instMesh.instanceColor.getX(srcIdx),
                    instMesh.instanceColor.getY(srcIdx),
                    instMesh.instanceColor.getZ(srcIdx)
                );
            });
            aAttr.needsUpdate = true;
            cAttr.needsUpdate = true;

            /* 3️⃣  hover housekeeping */
            if (hovered && !liveIds.has(hovered)) {
                hovered = hoveredIdx = null;
                selPane.textContent = '// Hover or click a node…';
            }
        }




        //////////////////////////////////////////////////////////////////////
        // CAMERA DOLLY / TWEEN
        //////////////////////////////////////////////////////////////////////
        function tweenToNode(ctxId) {
            const n = nodeMap.get(ctxId);
            if (!n || !instMesh) return;

            /* 1️⃣  convert the node's *stored* local pos → world space *now* */
            const worldPos = n.pos.clone();          // local
            graphGroup.updateMatrixWorld();          // make sure world matrix is current
            graphGroup.localToWorld(worldPos);       // local → world

            /* 2️⃣  define camera path */
            const fromPos = camera.position.clone();
            const fromTarget = orbitControls.target.clone();

            /* back the camera off slightly so the sphere isn't inside the near-plane */
            const toTarget = worldPos;
            const toPos = worldPos.clone().add(new THREE.Vector3(0, 100, 100)); // 10 up, 30 back

            /* 3️⃣  set up the tween */
            cameraTween = {
                fromPos, toPos,
                fromTarget, toTarget,
                start: performance.now(),
                duration: 600
            };
        }

        //////////////////////////////////////////////////////////////////////
        // DETAIL PANEL
        //////////////////////////////////////////////////////////////////////
        function populateDetail(id) {
            const obj = nodeMap.get(id).data;
            detailPanel.innerHTML = '';
            const tbl = document.createElement('table');

            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                tdK.textContent = k;
                const tdV = document.createElement('td');

                // references array
                if (Array.isArray(v) && k === 'references') {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.textContent = rid;
                        a.className = 'ref-link';
                        a.onclick = e => {
                            e.preventDefault();
                            tweenToNode(rid);

                            // expand sidebar dropdown for this context_id
                            const dropdown = document.getElementById(`dropdown-${rid}`);
                            if (dropdown) dropdown.style.display = 'block';

                            // clear previous highlights
                            document.querySelectorAll('.sidebar-item-highlight')
                                .forEach(el => el.classList.remove('sidebar-item-highlight'));

                            // highlight & scroll to the first item container
                            const itemEl = document.getElementById(`sidebar-item-container-${rid}-0`);
                            if (itemEl) {
                                itemEl.classList.add('sidebar-item-highlight');
                                itemEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        };
                        tdV.appendChild(a);
                    });

                    // association_strengths object
                } else if (typeof v === 'object' && v !== null && k === 'association_strengths') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.textContent = `${rid} (${w})`;
                        a.className = 'ref-link';
                        a.onclick = e => {
                            e.preventDefault();
                            tweenToNode(rid);

                            // same sidebar logic as above
                            const dropdown = document.getElementById(`dropdown-${rid}`);
                            if (dropdown) dropdown.style.display = 'block';
                            document.querySelectorAll('.sidebar-item-highlight')
                                .forEach(el => el.classList.remove('sidebar-item-highlight'));
                            const itemEl = document.getElementById(`sidebar-item-container-${rid}-0`);
                            if (itemEl) {
                                itemEl.classList.add('sidebar-item-highlight');
                                itemEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = typeof v === 'object' ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });

            detailPanel.appendChild(tbl);
        }

        //////////////////////////////////////////////////////////////////////
        // CHAIN REACTION
        //////////////////////////////////////////////////////////////////////
        /**
         * Starting from `nodeId`, walk *all* references upstream
         * (breadth‐first) and pulse every connecting edge white.
         * Uses your existing pulseEdge(idx, baseGrey) which fades it back.
         */
        function highlightPathFrom(nodeId) {
            if (!instEdge || !edges.length) return;
            const seen = new Set([nodeId]);
            const queue = [nodeId];
            const axisY = new THREE.Vector3(0, 1, 0);

            while (queue.length) {
                const srcId = queue.shift();
                const srcNode = nodeMap.get(srcId);
                if (!srcNode) continue;

                // collect both references[] + association_strengths keys
                const ups = [
                    ...(srcNode.data.references || []),
                    ...Object.keys(srcNode.data.association_strengths || {})
                ];

                for (const tgtId of ups) {
                    if (!nodeMap.has(tgtId) || seen.has(tgtId)) continue;
                    seen.add(tgtId);
                    queue.push(tgtId);

                    // find the edge index that joins srcId -> tgtId
                    const e = edges.find(e =>
                        (e.source === srcId && e.target === tgtId) ||
                        (e.source === tgtId && e.target === srcId)
                    );
                    if (e) {
                        // pulse white, then fade back to its original grey
                        const baseGrey = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);
                        pulseEdge(e.index, baseGrey);
                    }
                }
            }
        }


        /***********************************************************************
     *  Bright-flash a single edge, then fade back to its original dim value
     **********************************************************************/
        // ─── 1) Improved pulseEdge that restores *both* color & alpha ─────────
        function pulseEdge(edgeIdx, peakAlpha = 1) {
            if (!instEdge) return;
            const cAttr = instEdge.instanceColor;
            const aAttr = instEdge.geometry.attributes.alpha;

            // stash original
            const r0 = cAttr.getX(edgeIdx),
                g0 = cAttr.getY(edgeIdx),
                b0 = cAttr.getZ(edgeIdx),
                a0 = aAttr.getX(edgeIdx);

            // flash to white & full alpha
            cAttr.setXYZ(edgeIdx, 1, 1, 1);
            aAttr.setX(edgeIdx, peakAlpha);
            cAttr.needsUpdate = true;
            aAttr.needsUpdate = true;

            // fade back after fadeOutDuration
            setTimeout(() => {
                if (!instEdge) return;
                cAttr.setXYZ(edgeIdx, r0, g0, b0);
                aAttr.setX(edgeIdx, a0);
                cAttr.needsUpdate = true;
                aAttr.needsUpdate = true;
            }, DISPLAY_CONFIG.fadeOutDuration);
        }
        // ─── 2) Full upstream cascade with per-hop delay ────────────────────────
        function cascadeChain(originId, maxDepth = 10, delayStep = 200) {
            const visited = new Set([originId]);

            function walk(id, depth) {
                if (depth >= maxDepth) return;
                const node = nodeMap.get(id);
                if (!node) return;

                // gather *all* upstream neighbors
                const neighbors = [
                    ... (node.data.references || []),
                    ...Object.keys(node.data.association_strengths || {})
                ];

                neighbors.forEach(tgtId => {
                    if (visited.has(tgtId)) return;
                    visited.add(tgtId);

                    // find the edge object (bi-directional)
                    const edgeObj = edges.find(e =>
                        (e.source === id && e.target === tgtId) ||
                        (e.source === tgtId && e.target === id)
                    );
                    if (!edgeObj) return;

                    // schedule a pulse with increasing delay
                    setTimeout(() => {
                        const peak = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, edgeObj.weight);
                        pulseEdge(edgeObj.index, peak);
                    }, depth * delayStep);

                    // recurse upstream from this neighbor
                    walk(tgtId, depth + 1);
                });
            }

            // start the cascade
            walk(originId, 1);
        }


        function flashNeighbours(nodeId) {
            edges.forEach(e => {
                if (e.source === nodeId || e.target === nodeId) pulseEdge(e.index);
            });
        }


        function triggerChain(nodeId, depth = 0) {
            if (!nodeId || depth > DISPLAY_CONFIG.maxChainDepth) return;

            edges.forEach(e => {
                const nbr = e.source === nodeId ? e.target
                    : e.target === nodeId ? e.source
                        : null;
                if (!nbr) return;

                const delay = DISPLAY_CONFIG.chainDelay * 1000 * (depth + 1);
                const base = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);

                setTimeout(() => pulseEdge(e.index, base), delay);
                setTimeout(() => triggerChain(nbr, depth + 1), delay);
            });
        }


        function onPointerMove(ev) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', onClick);

        function onClick(ev) {
            // update pointer & do the raycast
            onPointerMove(ev);
            if (!instMesh) {
                // clicked without any mesh loaded → re-enable auto-scroll
                autoScrollEnabled = true;
                return;
            }

            scene.updateMatrixWorld();
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObject(instMesh, false)[0];

            // if you clicked empty space (or missed), re-enable auto-scroll
            if (!hit || hit.instanceId === undefined) {
                autoScrollEnabled = true;
                return;
            }

            // you clicked a node → pause auto-scroll
            autoScrollEnabled = false;

            // identify which context_id
            const clickedIdx = hit.instanceId;
            const ctxEntry = [...nodeMap.entries()]
                .find(([, n]) => n._instanceIndex === clickedIdx);
            if (!ctxEntry) return;
            const [ctxId, node] = ctxEntry;

            // remember selection & recolour immediately
            hovered = selectedId = ctxId;
            applyFilters();

            // show JSON preview
            selPane.textContent = JSON.stringify(node.data, null, 2);

            // build the detail table
            detailPanel.innerHTML = '';
            const ts0 = parseTimestamp(node.data.timestamp).getTime();
            const tbl = document.createElement('table');
            for (const [k, v] of Object.entries(node.data)) {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                const tdV = document.createElement('td');
                tdK.textContent = k;

                if (k === 'references' && Array.isArray(v)) {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = rid;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };

                        const ref = nodeMap.get(rid);
                        if (ref) {
                            const delta = ts0 - parseTimestamp(ref.data.timestamp).getTime();
                            const decay = Math.exp(-(delta / 86_400_000) / 7).toFixed(2);
                            const span = document.createElement('span');
                            span.style.marginLeft = '6px';
                            span.textContent = `(decay: ${decay})`;
                            a.appendChild(span);
                        }
                        tdV.appendChild(a);
                    });

                } else if (k === 'association_strengths' && typeof v === 'object') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = `${rid} (${w})`;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = typeof v === 'object' ? JSON.stringify(v) : v;
                }

                tr.append(tdK, tdV);
                tbl.appendChild(tr);
            }
            detailPanel.appendChild(tbl);

            // visual feedback on graph
            cascadeChain(ctxId);
            // and still animate camera
            tweenToNode(ctxId);

            // scroll & highlight in sidebar
            document.querySelectorAll('.sidebar-item-highlight')
                .forEach(el => el.classList.remove('sidebar-item-highlight'));

            const dropdown = document.getElementById(`dropdown-${ctxId}`);
            if (dropdown) dropdown.style.display = 'block';

            const header = document.getElementById(`header-${ctxId}`);
            if (header) {
                header.classList.add('sidebar-item-highlight');
                header.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }



        function buildTraversalPath(id) {
            traversalPath = [id];
            let cur = id;
            while (true) {
                const refs = nodeMap.get(cur).data.references || [];
                if (!refs[0] || !nodeMap.has(refs[0])) break;
                cur = refs[0];
                traversalPath.push(cur);
            }
            pathIndex = 0;
        }


        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            orbitControls.enableRotate = !timeMode;
        });

        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);

        // ─── header clocks ────────────────────────────────
        const now = new Date();
        const viewTime = new Date(now - graphGroup.position.y * LAYOUT_CONFIG.msPerUnit);

        nowLbl.textContent = 'Now:  ' + now.toLocaleString();
        viewLbl.textContent = 'View: ' + viewTime.toLocaleString();
        /********************************************************************
         *  Animation loop  (COMPLETE, SELF-CONTAINED)
         *******************************************************************/
        // ─── replace your old animate() with this ───────────────────────────
        function animate() {
            requestAnimationFrame(animate);

            /* 0) timing & OrbitControls ------------------------------------------------ */
            const now = performance.now();
            const delta = (now - prevTime) / 1000;
            prevTime = now;
            orbitControls.update();

            /* 1) vision tracking (head pose + hands) ---------------------------------- */
            if (video && faceLandmarker && handLandmarker &&
                video.readyState >= HTMLMediaElement.HAVE_METADATA) {

                const fRes = faceLandmarker.detectForVideo(video, now);
                const hRes = handLandmarker.detectForVideo(video, now);

                /* 1a) head pose → camera (unchanged) ------------------------------------ */
                if (fRes.facialTransformationMatrixes?.length) {
                    const m = fRes.facialTransformationMatrixes[0].data;
                    poseTransform.matrix.fromArray(m);
                    poseTransform.matrix.decompose(
                        poseTransform.position,
                        poseTransform.quaternion,
                        poseTransform.scale
                    );
                    const e = new THREE.Euler().setFromQuaternion(poseTransform.quaternion, 'YXZ');
                    headSmooth.y = THREE.MathUtils.lerp(headSmooth.y, e.y - prevEuler.y, HEAD_SMOOTH_FACTOR);
                    headSmooth.p = THREE.MathUtils.lerp(headSmooth.p, e.x - prevEuler.x, HEAD_SMOOTH_FACTOR);
                    headSmooth.r = THREE.MathUtils.lerp(headSmooth.r, e.z - prevEuler.z, HEAD_SMOOTH_FACTOR);
                    orbitCamera(-headSmooth.y, headSmooth.p, -headSmooth.r);
                    prevEuler.copy(e);
                }

                /* 1b) HANDS -------------------------------------------------------------- */
                if (hRes.landmarks?.length) {

                    // clear previous hand meshes
                    fingerGroup.clear();

                    // plane in front of the camera to project the 2‑D MediaPipe coords
                    const camDir = new THREE.Vector3();
                    camera.getWorldDirection(camDir);
                    const planePt = camera.position.clone().add(camDir.clone().multiplyScalar(HAND_DRAW_DISTANCE));
                    const projPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, planePt);

                    // book‑keeping for both hands this frame
                    const hands = { Left: null, Right: null };

                    hRes.landmarks.forEach((lm, i) => {
                        /* handedness */
                        const handName = (hRes.handednesses[i][0] || hRes.handednesses[i]).categoryName; // 'Left'/'Right'
                        const isLeft = handName === 'Left';

                        /* simple grey for joints / bones */
                        const jointMat = new THREE.MeshBasicMaterial({ color: isLeft ? 0x888888 : 0xaaaaaa });
                        const boneMat = new THREE.LineBasicMaterial({ color: isLeft ? 0x888888 : 0xaaaaaa });

                        /* draw joints & bones (unchanged) … ---------------------------------- */
                        lm.forEach(pt => {
                            const xN = (1 - pt.x) * 2 - 1, yN = -(pt.y * 2 - 1);
                            raycaster.setFromCamera({ x: xN, y: yN }, camera);
                            const P = new THREE.Vector3();
                            if (raycaster.ray.intersectPlane(projPlane, P)) {
                                const s = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), jointMat);
                                s.position.copy(P);
                                fingerGroup.add(s);
                            }
                        });

                        const bones = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8],
                        [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16],
                        [0, 17], [17, 18], [18, 19], [19, 20]];
                        bones.forEach(([a, b]) => {
                            const pa = lm[a], pb = lm[b];
                            const xa = (1 - pa.x) * 2 - 1, ya = -(pa.y * 2 - 1);
                            const xb = (1 - pb.x) * 2 - 1, yb = -(pb.y * 2 - 1);
                            raycaster.setFromCamera({ x: xa, y: ya }, camera);
                            const A = new THREE.Vector3();
                            const hitA = raycaster.ray.intersectPlane(projPlane, A);
                            raycaster.setFromCamera({ x: xb, y: yb }, camera);
                            const B = new THREE.Vector3();
                            const hitB = raycaster.ray.intersectPlane(projPlane, B);
                            if (hitA && hitB) {
                                const geo = new THREE.BufferGeometry().setFromPoints([A, B]);
                                fingerGroup.add(new THREE.Line(geo, boneMat));
                            }
                        });

                        /* pinch metrics ------------------------------------------------------ */
                        const t4 = lm[4], t8 = lm[8];
                        const pinchDist = Math.hypot(t4.x - t8.x, t4.y - t8.y);
                        const mid = { x: (t4.x + t8.x) / 2, y: (t4.y + t8.y) / 2 };
                        hands[handName] = { dist: pinchDist, mid, lm };
                    });

                    /* ── LEFT‑hand single‑pinch tracking ➜ #datadrop ---------------------- */
                    const dDrop = document.getElementById('datadrop') || (() => {
                        const div = document.createElement('div'); div.id = 'datadrop';
                        Object.assign(div.style, {
                            position: 'fixed', bottom: '4px', left: '4px',
                            font: '600 0.8rem/1.2 monospace', color: '#0f0', pointerEvents: 'none', zIndex: 999
                        });
                        document.body.appendChild(div); return div;
                    })();

                    const L = hands.Left;
                    if (L && L.dist < PINCH_THRESHOLD) {          // pinch is **ON**
                        if (!leftPinchActive) {                     // …just started
                            leftPinchActive = true;
                            leftPinchStartMid = { ...L.mid };           // shallow copy
                        }
                        // delta in normalised screen space (‑1…1).  Flip Y so +Y = up.
                        leftPinchDelta.x = (L.mid.x - leftPinchStartMid.x);
                        leftPinchDelta.y = -(L.mid.y - leftPinchStartMid.y);

                        // write to HUD
                        dDrop.textContent =
                            `Δx: ${leftPinchDelta.x.toFixed(3)}   Δy: ${leftPinchDelta.y.toFixed(3)}`;
                    } else {                                      // pinch released
                        if (leftPinchActive) {
                            leftPinchActive = false;
                            leftPinchStartMid = null;
                            leftPinchDelta.x = leftPinchDelta.y = 0;
                            dDrop.textContent = '(pinch released)';
                        }
                    }

                    
                   
                    /* ── two‑hand pinch zoom (unchanged) ---------------------------------- */
                    const R = hands.Right;
                    if (L && R && L.dist < PINCH_THRESHOLD && R.dist < PINCH_THRESHOLD) {
                        const dx = L.mid.x - R.mid.x, dy = L.mid.y - R.mid.y;
                        const midDist = Math.hypot(dx, dy);
                        if (prevHandsMidDist !== null) {
                            const dd = midDist - prevHandsMidDist;
                            const zoom = dd * ZOOM_SENSITIVITY;
                            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
                            camera.position.addScaledVector(dir, zoom); orbitControls.update();
                        }
                        prevHandsMidDist = midDist;
                    } else prevHandsMidDist = null;
 /* ── RIGHT‑hand single‑pinch → camera orbit ───────────────────────── */
                    if ( R && R.dist < PINCH_THRESHOLD && !( L && L.dist < PINCH_THRESHOLD ) ) {

                    // ① pinch just started
                    if ( !rightPinchActive ) {
                        rightPinchActive   = true;
                        rightPinchStartMid = { ...R.mid };          // remember initial mid‑point
                    }

                    // ② delta since last frame (screen‑space −1…+1, Y flipped so +Y = up)
                    const dX =  ( R.mid.x - rightPinchStartMid.x );
                    const dY = -( R.mid.y - rightPinchStartMid.y );

                    // ③ apply orbit (scale by sensitivity)
                    orbitCamera( -dX * RIGHT_ROTATE_SENSITIVITY,
                                -dY * RIGHT_ROTATE_SENSITIVITY,
                                    0 );

                    orbitControls.update();               // keep damping in sync

                    // ④ reset start point so movement is incremental
                    rightPinchStartMid = { ...R.mid };

                    } else {
                    rightPinchActive   = false;
                    rightPinchStartMid = null;
                    }
                    /* ── glow line on any pinched hand (unchanged) ------------------------ */
                    ['Left', 'Right'].forEach(name => {
                        const h = hands[name];
                        if (!h || h.dist > PINCH_THRESHOLD) return;
                        const t4 = h.lm[4], t8 = h.lm[8];
                        const x4 = (1 - t4.x) * 2 - 1, y4 = -(t4.y * 2 - 1);
                        const x8 = (1 - t8.x) * 2 - 1, y8 = -(t8.y * 2 - 1);
                        raycaster.setFromCamera({ x: x4, y: y4 }, camera);
                        const A = new THREE.Vector3();
                        const hitA = raycaster.ray.intersectPlane(projPlane, A);
                        raycaster.setFromCamera({ x: x8, y: y8 }, camera);
                        const B = new THREE.Vector3();
                        const hitB = raycaster.ray.intersectPlane(projPlane, B);
                        if (hitA && hitB) {
                            const glowMat = new THREE.LineBasicMaterial({ color: 0xffaa00, linewidth: 4 });
                            const glowGeo = new THREE.BufferGeometry().setFromPoints([A, B]);
                            fingerGroup.add(new THREE.Line(glowGeo, glowMat));
                        }
                    });
                }
            }

            // ─── 2) smooth scroll + drift in Tree‑Mode only ───────────────────────
            if (!brainMode) {
                if (Math.abs(scrollVelocity) > 1e-4) {
                    yScrollOffset = Math.min(0, yScrollOffset + scrollVelocity);
                    scrollVelocity *= SCROLL_FRICTION;
                } else {
                    scrollVelocity = 0;
                }
                const nowMs = Date.now();
                const dt = nowMs - lastDriftT;
                yScrollOffset += (dt * LAYOUT_CONFIG.driftFactor) / MS_PER_UNIT;
                lastDriftT = nowMs;
                graphGroup.position.y = yScrollOffset;
            } else {
                graphGroup.position.y = 0;
            }

            // ─── 3) header clocks & decay ──────────────────────────────────────
            const nowDate = new Date();
            const elapsedMs = -yScrollOffset * MS_PER_UNIT;
            const viewDate = new Date(nowDate - elapsedMs);
            nowLbl.textContent = 'Now:  ' + nowDate.toLocaleString();
            viewLbl.textContent = 'View: ' + viewDate.toLocaleString();
            scrollBoost = Math.max(1, scrollBoost * BOOST_DECAY);

            // ─── 4) camera fly‑to tween ────────────────────────────────────────
            if (cameraTween) {
                const tCam = Math.min((now - cameraTween.start) / cameraTween.duration, 1);
                camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, tCam);
                orbitControls.target.lerpVectors(cameraTween.fromTarget, cameraTween.toTarget, tCam);
                if (tCam >= 1) cameraTween = null;
            }

            // ─── 5) node‑position & scale tweens ───────────────────────────────
            if (!brainMode) {
                const nowT = performance.now();
                let moved = false;
                nodeMap.forEach(entry => {
                    if (entry.tweenStart) {
                        const t = Math.min((nowT - entry.tweenStart) / entry.tweenDuration, 1);
                        const ip = entry.prevPos.clone().lerp(entry.pos, t);
                        const mat = new THREE.Matrix4().compose(ip, new THREE.Quaternion(), new THREE.Vector3(1, 1, 1));
                        instMesh.setMatrixAt(entry._instanceIndex, mat);
                        moved = true;
                        if (t === 1) {
                            delete entry.tweenStart;
                            entry.prevPos.copy(entry.pos);
                        }
                    }
                    if (entry.scaleTweenStart) {
                        const t2 = Math.min((nowT - entry.scaleTweenStart) / entry.scaleTweenDuration, 1);
                        const scale = entry.scalePrev.clone().lerp(entry.scaleTarget, t2);
                        const mat2 = new THREE.Matrix4().compose(entry.pos, new THREE.Quaternion(), scale);
                        instMesh.setMatrixAt(entry._instanceIndex, mat2);
                        moved = true;
                        if (t2 === 1) delete entry.scaleTweenStart;
                    }
                });
                if (moved) {
                    instMesh.instanceMatrix.needsUpdate = true;
                    updateEdgeMeshes();
                }
            }

            // ─── 6) hover & click feedback ─────────────────────────────────────
            if (instMesh) {
                scene.updateMatrixWorld();
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObject(instMesh, false)[0];
                if (hit && hit.instanceId !== undefined) {
                    const idx = hit.instanceId;
                    if (idx !== hoveredIdx) {
                        hoveredIdx = idx;
                        const found = [...nodeMap.entries()].find(([, n]) => n._instanceIndex === idx);
                        if (found) {
                            const [ctxId, node] = found;
                            hovered = ctxId;
                            selPane.textContent = JSON.stringify(node.data, null, 2);
                            populateDetail(ctxId);
                            flashNeighbours(ctxId);
                            document.querySelectorAll('.sidebar-item-highlight').forEach(e => e.classList.remove('sidebar-item-highlight'));
                            const el = document.querySelector(`[id^="sidebar-item-container-${ctxId}-"]`);
                            if (el) {
                                el.classList.add('sidebar-item-highlight');
                                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                } else {
                    hoveredIdx = hovered = null;
                    document.querySelectorAll('.sidebar-item-highlight').forEach(e => e.classList.remove('sidebar-item-highlight'));
                }
            }
            if (hovered !== previousHoveredId) {
                previousHoveredId = hovered;
                if (instMesh) instMesh.material.emissiveIntensity = 0;
            }

            // ─── 7) final render ──────────────────────────────────────────────
            renderer.render(scene, camera);
        }

        // start it up
        animate();


        ensureEdgeAlphaAttr();   // make alpha buffer immediately
        rebuildEdges();
        populateFileSelector()
            .then(loadGraph)
            .then(() => {
                // after your initial loadGraph, seed lastContextId:
                if (allData.length) {
                    lastContextId = allData[allData.length - 1].context_id;
                }
                setInterval(pollForNew, POLL_INTERVAL);
            })
            .catch(err => {
                console.error(err);
                loadGraph().then(() => {
                    if (allData.length) lastContextId = allData[allData.length - 1].context_id;
                    setInterval(pollForNew, POLL_INTERVAL);
                });
            });
        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>