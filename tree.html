<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Context Graph Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: Arial, Helvetica, sans-serif;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 10;
        }

        #ui label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-right: 4px;
        }

        #ui select,
        #ui button {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 2px 6px;
            font-size: 0.9rem;
        }

        #selectednode {
            position: fixed;
            top: 3em;
            right: 0;
            width: 30%;
            max-width: 300px;
            height: 40%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            padding: 8px;
            font-size: 0.8rem;
            border-top-left-radius: 6px;
            box-sizing: border-box;
            white-space: pre-wrap;
            z-index: 9;
        }

        #detailPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 30%;
            max-width: 300px;
            height: 40%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            padding: 8px;
            font-size: 0.8rem;
            border-top-right-radius: 6px;
            box-sizing: border-box;
            z-index: 9;
        }

        #detailPanel table {
            width: 100%;
            border-collapse: collapse;
        }

        #detailPanel td {
            padding: 4px;
            border-bottom: 1px solid #444;
            vertical-align: top;
        }

        #detailPanel td:first-child {
            font-weight: bold;
            width: 30%;
        }

        a.ref-link {
            color: #6cf;
            text-decoration: underline;
            cursor: pointer;
            margin-right: 6px;
        }

        canvas {
            display: block;
        }
    </style>

    <!-- import map for three.js -->
    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
      "three/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>
</head>

<body>
    <!-- ─── CONTROL BAR ─────────────────────────────────────────────────── -->
    <div id="ui">
        <label for="fileSelector">File:</label>
        <select id="fileSelector">\
        </select>

        <label for="ageFilter">Age window:</label>
        <select id="ageFilter">
            <option value="all">All</option>
            <option value="h1">Last hour</option>
            <option value="d1">Last 24 h</option>
            <option value="w1">Last 7 days</option>
            <option value="m1">Last 30 days</option>
        </select>

        <label for="typeFilter">Type / Tag:</label>
        <select id="typeFilter">
            <option value="all">All</option>
        </select>

        <button id="timeToggle">Time Mode</button>
    </div>

    <!-- ─── HOVER JSON PANE ─────────────────────────────────────────────── -->
    <div id="selectednode">// Hover or click a node…</div>

    <!-- ─── DETAIL TABLE PANEL ─────────────────────────────────────────── -->
    <div id="detailPanel"></div>

    <!-- ─── THREE.JS + LOGIC ─────────────────────────────────────────────── -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/OrbitControls';

        //////////////////////////////////////////////////////////////////////
        // CONFIG
        //////////////////////////////////////////////////////////////////////
        const LAYOUT_CONFIG = {
            msPerUnit: 1000 * 6,   // 1 min realtime = 1 Y-unit
            maxXZRadius: 500,
            minSphereY: 0
        };
        const DISPLAY_CONFIG = {
            sphereRadius: 5,
            sphereSegments: 3,
            lineBaseOpacity: 0.1,
            hoverHighlightOpacity: 0.5,
            chainDelay: 2,
            maxChainDepth: 3,
            fadeOutDuration: 1
        };

        //////////////////////////////////////////////////////////////////////
        // UI & STATE
        //////////////////////////////////////////////////////////////////////
        const fileSelector = document.getElementById('fileSelector');

        const ageSel = document.getElementById('ageFilter');
        const typeSel = document.getElementById('typeFilter');
        const timeToggle = document.getElementById('timeToggle');
        const selPane = document.getElementById('selectednode');
        const detailPanel = document.getElementById('detailPanel');

        const MAX_NODES = 5000;

        let pickableMeshes = [];
        let visibleMeshes = [];

        let nodeMap = new Map();
        let edges = [];
        let prevCount = 0;
        let timeMode = false;
        let selectedId = null;
        let traversalPath = [], pathIndex = 0;
        let previousHoveredId = null;
        let cameraTween = null;
        let hueMapCurrent = {};   // component → hue (0-1)
        let maxConnCurrent = 1;    // highest connectivity in the dataset

        // ←── Add this so instMesh is visible everywhere ──→
        let instMesh = null;
        let instEdge = null;
        let hovered = null;
        let hoveredIdx = null;
        let yScrollOffset = 0;
        // last time we applied that drift
        let lastDriftT = Date.now();

        // ←── PICKABLE INSTANCES SETUP ──→
        pickableMeshes.length = 0;
        const comps = [...new Set([...nodeMap.values()].map(n => n.data.component))];
        const hueMap = Object.fromEntries(comps.map((c, i) => [c, i / comps.length]));

        function getContextFileUrl(cacheBust = false) {
            let fn = fileSelector.value;
            if (!/^context(?:_-?\d+)?\.jsonl$/.test(fn)) fn = 'context.jsonl';
            return `http://0.0.0.0:8000/${fn}` + (cacheBust ? `?_=${Date.now()}` : '');
        }
        async function populateFileSelector() {
            try {
                const res = await fetch('/', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const txt = await res.text();
                let files = [];

                // 1) try JSON
                try {
                    const arr = JSON.parse(txt);
                    if (Array.isArray(arr)) {
                        files = arr;
                    } else {
                        throw new Error('JSON is not an array');
                    }
                } catch (jsonErr) {
                    console.warn('Could not parse /files as JSON, falling back to HTML scrape:', jsonErr);
                    // 2) fallback — pull href="context_....jsonl"
                    const regex = /href="(context(?:_-?\d+)?\.jsonl)"/g;
                    let m;
                    while ((m = regex.exec(txt))) {
                        files.push(m[1]);
                    }
                }

                // 3) dedupe & filter
                const unique = Array.from(new Set(files))
                    .filter(f => /^context(?:_-?\d+)?\.jsonl$/.test(f));

                // 4) rebuild the <select>
                fileSelector.innerHTML = unique
                    .map(f => `<option value="${f}">${f}</option>`)
                    .join('');

            } catch (err) {
                console.warn('populateFileSelector failed; keeping existing <option>s:', err);
                // leave whatever was in <select> alone
            }
        }

        // wire it up:
        fileSelector.addEventListener('change', () => loadGraph());

        // on startup:
        populateFileSelector()
            .then(() => loadGraph(fileSelector.value))
            .catch(() => {
                /* ignore—populateFileSelector already logged */
                loadGraph(fileSelector.value);
            });
        // ——— REPLACEMENT ———
        let isBuilding = false;
        //////////////////////////////////////////////////////////////////////////
        // BATCHED NODE CREATION
        //////////////////////////////////////////////////////////////////////////

        // break up large inserts into ~500-item chunks so the browser stays responsive
        async function batchAddNodes(objects) {
            isBuilding = true;
            const chunkSize = 500;
            for (let i = 0; i < objects.length; i += chunkSize) {
                const batch = objects.slice(i, i + chunkSize);
                addNodes(batch);
                rebuildEdges();
                // let the browser breathe
                await new Promise(r => requestAnimationFrame(r));
            }
            isBuilding = false;
        }

        function addNodes(objs) {
            const now = Date.now();

            // 1) Create the instanced sphere mesh once
            if (!instMesh) {
                const geo = new THREE.SphereGeometry(
                    DISPLAY_CONFIG.sphereRadius,
                    DISPLAY_CONFIG.sphereSegments,
                    DISPLAY_CONFIG.sphereSegments
                );
                const mat = new THREE.MeshLambertMaterial({ vertexColors: true });
                instMesh = new THREE.InstancedMesh(geo, mat, MAX_NODES);

                const cAttr = new THREE.InstancedBufferAttribute(
                    new Float32Array(MAX_NODES * 3), 3
                );
                instMesh.geometry.setAttribute('color', cAttr);
                instMesh.instanceColor = cAttr;
                graphGroup.add(instMesh);
            }

            // 2) Ingest all new objects into nodeMap
            objs.forEach(o => {
                if (nodeMap.has(o.context_id)) return;  // skip duplicates

                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;

                // Compute position (Y = age, XZ random scatter by connectivity)
                const pos = new THREE.Vector3();
                const age = now - parseTimestamp(o.timestamp).getTime();
                pos.y = Math.max(LAYOUT_CONFIG.minSphereY, age / LAYOUT_CONFIG.msPerUnit);
                const rNorm = 1 - conn / 1;
                const r = rNorm * LAYOUT_CONFIG.maxXZRadius;
                const a = Math.random() * Math.PI * 2;
                pos.x = Math.cos(a) * r;
                pos.z = Math.sin(a) * r;

                nodeMap.set(o.context_id, {
                    data: o,
                    pos,
                    connectivity: conn,
                    mesh: instMesh
                });
            });

            // 3) Recompute stats for coloring
            maxConnCurrent = Math.max(
                1, ...[...nodeMap.values()].map(n => n.connectivity)
            );
            const comps = [...new Set([...nodeMap.values()].map(n => n.data.component))];
            hueMapCurrent = Object.fromEntries(comps.map((c, i) => [c, i / comps.length]));

            // 4) Rewrite all instance matrices & colors
            const color = new THREE.Color();
            let idx = 0;
            nodeMap.forEach(n => {
                if (idx >= MAX_NODES) return;
                instMesh.setMatrixAt(idx, new THREE.Matrix4().setPosition(
                    n.pos.x, n.pos.y, n.pos.z
                ));
                const hue = hueMapCurrent[n.data.component] || 0;
                const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                instMesh.instanceColor.setXYZ(
                    idx,
                    ...color.setHSL(hue, sat, 0.5).toArray()
                );
                n._instanceIndex = idx;
                idx++;
            });
            instMesh.count = idx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // 5) Rebuild edges into the instanced edge mesh
            rebuildEdges();
        }

        // recompute max connectivity once per batch
        function computeMaxConnectivity() {
            return Math.max(
                1,
                ...[...nodeMap.values()].map(n => n.connectivity)
            );
        }

        // initial full load with verbose logging
        async function loadGraph() {
            console.log('[loadGraph] starting full graph load from', getContextFileUrl(false));

            clearScene();
            initEdges();          // must be defined *after* you create edgeMaterial
            hovered = hoveredIdx = null;
            prevCount = 0;

            try {
                const res = await fetch(getContextFileUrl(true));
                const txt = await res.text();
                const lines = txt.trim().split(/\r?\n/);
                console.log(`[loadGraph] fetched ${lines.length} lines`);
                prevCount = lines.length;

                const objs = lines.map((l, i) => {
                    try { return JSON.parse(l); }
                    catch (e) { console.error(`JSON.parse error line ${i}`, e); return null; }
                }).filter(Boolean);

                await batchAddNodes(objs); // calls addNodes() → rebuildEdges()
                rebuildEdges();

                populateTypeFilter(Array.from(nodeMap.values(), n => n.data));
                applyFilters();
                console.log('[loadGraph] done');
            } catch (err) {
                console.error('[loadGraph] error loading graph:', err);
            }
        }


        // incremental updater with verbose logging and dynamic scene update
        async function pollForNew() {
            console.log('[pollForNew] checking for updates...');
            try {
                const res = await fetch(getContextFileUrl(true), { cache: 'no-store' });
                const txt = await res.text();
                const all = txt.trim().split(/\r?\n/);
                console.log(`[pollForNew] ${all.length} total lines, prevCount=${prevCount}`);

                if (all.length > prevCount && !isBuilding) {
                    const newLines = all.slice(prevCount);
                    console.log(`[pollForNew] ${newLines.length} new line(s)`);

                    const added = newLines.map((l, i) => {
                        try { return JSON.parse(l); }
                        catch {
                            console.error(`[pollForNew] parse error on new line ${i}`);
                            return null;
                        }
                    }).filter(Boolean);

                    prevCount = all.length;
                    await batchAddNodes(added);   // this calls addNodes() → rebuildEdges()

                    // update UI
                    populateTypeFilter([...nodeMap.values()].map(n => n.data));
                    applyFilters();

                    // highlight newest
                    if (added.length) triggerChain(added[added.length - 1].context_id, 0);
                    console.log('[pollForNew] done');
                }
            } catch (err) {
                console.error('[pollForNew] error:', err);
            }
        }

        setInterval(pollForNew, 1000);

        // ─── BUILD SCENE ──────────────────────────────────────────────────
        function buildScene(objects) {
            // sort by timestamp (newest first)
            objects.sort((a, b) =>
                parseTimestamp(b.timestamp) - parseTimestamp(a.timestamp)
            );

            const now = Date.now();
            nodeMap.clear();

            // index + compute connectivity
            objects.forEach(o => {
                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;
                nodeMap.set(o.context_id, {
                    data: o,
                    mesh: null,
                    pos: new THREE.Vector3(),
                    connectivity: conn
                });
            });

            // layout: Y = age, XZ scatter by connectivity
            const maxConn = Math.max(...[...nodeMap.values()].map(n => n.connectivity), 1);
            nodeMap.forEach(n => {
                const age = now - parseTimestamp(n.data.timestamp).getTime();
                n.pos.y = Math.max(LAYOUT_CONFIG.minSphereY, age / LAYOUT_CONFIG.msPerUnit);
                const norm = 1 - (n.connectivity / maxConn);
                const r = norm * LAYOUT_CONFIG.maxXZRadius;
                const a = Math.random() * Math.PI * 2;
                n.pos.x = Math.cos(a) * r;
                n.pos.z = Math.sin(a) * r;
            });


            // 1) At initialization (once):

            {
                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 1, 0)
                ]);

                instEdge = new THREE.InstancedMesh(lineGeo, edgeMaterial, MAX_EDGES);
                instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instEdge.geometry.setAttribute(
                    'alpha',
                    new THREE.InstancedBufferAttribute(new Float32Array(MAX_EDGES), 1)
                        .setUsage(THREE.DynamicDrawUsage)
                );

                graphGroup.add(instEdge);
            }


            let ei = 0;
            nodeMap.forEach((n, id) => {
                // gather all connections
                const conns = new Map();
                (n.data.references || []).forEach(rid => conns.set(rid, 1));
                Object.entries(n.data.association_strengths || {}).forEach(([rid, w]) =>
                    conns.set(rid, Math.max(conns.get(rid) || 0, w))
                );

                conns.forEach((w, oid) => {
                    const tgt = nodeMap.get(oid);
                    if (!tgt) return;

                    // compute direction vector and length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const length = dir.length();
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        dir.normalize()
                    );

                    // build the instance transform
                    const matrix = new THREE.Matrix4().compose(
                        n.pos,                         // translation
                        quat,                          // orientation
                        new THREE.Vector3(1, length, 1) // scale (stretch line to length)
                    );

                    instEdge.setMatrixAt(ei, matrix);
                    instEdge.geometry.attributes.alpha.setX(
                        ei,
                        DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, w)
                    );
                    ei++;
                });
            });

            // finalize instance count and upload updates
            instEdge.count = ei;
            instEdge.geometry.attributes.alpha.needsUpdate = true;

            // refresh UI filters if needed…
            populateTypeFilter(objects);
            applyFilters();
        }
        // ─── INITIALIZE ──────────────────────────────────────────────────
        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        typeSel.addEventListener('change', applyFilters);
        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        populateFileSelector()
            .then(() => loadGraph());
        //////////////////////////////////////////////////////////////////////////
        // THREE.JS SETUP
        //////////////////////////////////////////////////////////////////////////
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            2e6
        );
        camera.position.set(0, 500, 500);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(1, 1, 1);
        scene.add(keyLight);

        const graphGroup = new THREE.Group();
        scene.add(graphGroup);

        //////////////////////////////////////////////////////////////////////////
        // EDGE INSTANCED MESH SETUP (skinny box)
        //////////////////////////////////////////////////////////////////////////
        const MAX_EDGES = 20_000;

        function initEdges() {
            if (instEdge) return; // already done

            // 0.1×1×0.1 box, base at Y=0 so scaling in Y stretches from node A to B naturally
            const edgeGeo = new THREE.BoxGeometry(0.1, 1, 0.1);
            edgeGeo.translate(0, 0.5, 0);

            const edgeMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: DISPLAY_CONFIG.lineBaseOpacity
            });

            instEdge = new THREE.InstancedMesh(edgeGeo, edgeMat, MAX_EDGES);
            instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            graphGroup.add(instEdge);
        }

        function rebuildEdges() {
            initEdges();
            let ei = 0;
            nodeMap.forEach((n, srcId) => {
                // gather all connections
                const links = new Map();
                (n.data.references || []).forEach(r => links.set(r, 1));
                Object.entries(n.data.association_strengths || {})
                    .forEach(([r, w]) => links.set(r, Math.max(links.get(r) || 0, w)));

                links.forEach((w, tgtId) => {
                    const tgt = nodeMap.get(tgtId);
                    if (!tgt || ei >= MAX_EDGES) return;

                    // compute direction & length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const len = dir.length();
                    if (len === 0) return;

                    // rotate unit‐box Y-axis into this direction
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        dir.clone().normalize()
                    );

                    // compose TRS: translate → n.pos, rotate → quat, scale Y → len
                    const m = new THREE.Matrix4().compose(
                        n.pos,                    // translation
                        quat,                     // rotation
                        new THREE.Vector3(1, len, 1) // scale
                    );

                    instEdge.setMatrixAt(ei, m);
                    ei++;
                });
            });

            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;              // push new transforms
        }

        //////////////////////////////////////////////////////////////////////////
        // USAGE—call these once at startup, then whenever nodeMap changes:
        //////////////////////////////////////////////////////////////////////////
        initEdges();
        // …after you load or add nodes:
        rebuildEdges();

        //////////////////////////////////////////////////////////////////////
        // HELPERS
        //////////////////////////////////////////////////////////////////////
        function parseTimestamp(ts) {
            const y = +ts.slice(0, 4), m = +ts.slice(4, 6) - 1, d = +ts.slice(6, 8),
                hh = +ts.slice(9, 11), mm = +ts.slice(11, 13), ss = +ts.slice(13, 15);
            return new Date(Date.UTC(y, m, d, hh, mm, ss));
        }
        function unixNow() { return Date.now(); }

        function clearScene() {
            // ── remove all meshes (nodes & edges) under graphGroup
            graphGroup.children.slice().forEach(child => {
                graphGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            // reset references to instanced meshes
            instMesh = null;
            instEdge = null;

            // reset group transform so next load starts at y = 0
            graphGroup.position.set(0, 0, 0);
            yScrollOffset = 0;
            lastDriftT = Date.now();

            // ── wipe JS-side state
            nodeMap.clear();
            edges.length = 0;
            pickableMeshes.length = 0;
            hovered = hoveredIdx = selectedId = null;
            prevCount = 0;

            // ── clear UI
            selPane.textContent = '// Hover or click a node…';
            detailPanel.innerHTML = '';
        }


        //////////////////////////////////////////////////////////////////////
        // FILTERS
        //////////////////////////////////////////////////////////////////////
        function populateTypeFilter(objs) {
            const bucket = new Set();
            objs.forEach(o => {
                bucket.add('domain:' + o.domain);
                bucket.add('component:' + o.component);
                (o.tags || []).forEach(t => bucket.add('tag:' + t));
            });
            typeSel.innerHTML = '<option value="all">All</option>';
            [...bucket].sort().forEach(k => {
                const opt = document.createElement('option');
                opt.value = k; opt.textContent = k;
                typeSel.appendChild(opt);
            });
        }
        // ——— applyFilters() for the single InstancedMesh + edge visibility ———
        function applyFilters() {
            const now = unixNow();
            const ageMax = ({ h1: 3600e3, d1: 86400e3, w1: 86400e3 * 7, m1: 86400e3 * 30 }[ageSel.value]) || 0;
            const pickVal = typeSel.value;
            const color = new THREE.Color();

            let writeIdx = 0;
            const liveIds = new Set();
            const selectedIds = new Set();

            // ── update node mesh ───────────────────────────────────────────────
            nodeMap.forEach((n, ctxId) => {
                // age filter
                if (ageMax) {
                    const age = now - parseTimestamp(n.data.timestamp).getTime();
                    if (age > ageMax) return;
                }
                liveIds.add(ctxId);

                // type/tag filter
                let ok = true;
                if (pickVal !== 'all') {
                    const [k, v] = pickVal.split(':');
                    if (k === 'domain') ok = n.data.domain === v;
                    if (k === 'component') ok = n.data.component === v;
                    if (k === 'tag') ok = (n.data.tags || []).includes(v);
                }
                if (ok) selectedIds.add(ctxId);

                // write instance
                instMesh.setMatrixAt(writeIdx, new THREE.Matrix4().setPosition(n.pos));
                const hue = hueMapCurrent[n.data.component] || 0;
                const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                const light = ok ? 0.5 : 0.25;
                instMesh.instanceColor.setXYZ(
                    writeIdx,
                    ...color.setHSL(hue, sat, light).toArray()
                );
                n._instanceIndex = writeIdx;
                writeIdx++;
            });

            instMesh.count = writeIdx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // ── update edge alphas on instanced edge mesh ───────────────────────
            if (instEdge && instEdge.geometry.attributes.alpha) {
                const aAttr = instEdge.geometry.attributes.alpha;

                edges.forEach(e => {
                    const bothLive = liveIds.has(e.source) && liveIds.has(e.target);
                    const bothSelected = selectedIds.has(e.source) && selectedIds.has(e.target);

                    const alpha = !bothLive
                        ? 0
                        : bothSelected
                            ? DISPLAY_CONFIG.lineBaseOpacity * e.weight
                            : DISPLAY_CONFIG.lineBaseOpacity * e.weight * 0.5;

                    aAttr.setX(e.index, alpha);
                });

                aAttr.needsUpdate = true;
            }

            // ── reset hover if it just became invisible ────────────────────────
            if (hovered && !liveIds.has(hovered)) {
                hovered = hoveredIdx = null;
                selPane.textContent = '// Hover or click a node…';
            }
        }




        //////////////////////////////////////////////////////////////////////
        // CAMERA DOLLY / TWEEN
        //////////////////////////////////////////////////////////////////////
        function tweenToNode(id) {
            const n = nodeMap.get(id);
            if (!n) return;
            const fromPos = camera.position.clone();
            const fromTarget = controls.target.clone();
            const toPos = new THREE.Vector3(n.pos.x, n.pos.y + 10, n.pos.z + 30);
            const toTarget = n.pos.clone();
            cameraTween = {
                fromPos, toPos,
                fromTarget, toTarget,
                start: performance.now(),
                duration: 600
            };
        }

        //////////////////////////////////////////////////////////////////////
        // DETAIL PANEL
        //////////////////////////////////////////////////////////////////////
        function populateDetail(id) {
            const obj = nodeMap.get(id).data;
            detailPanel.innerHTML = '';
            const tbl = document.createElement('table');
            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                tdK.textContent = k;
                const tdV = document.createElement('td');

                // references array
                if (Array.isArray(v) && k === 'references') {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.textContent = rid;
                        a.className = 'ref-link';
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });
                }
                // association_strengths object
                else if (typeof v === 'object' && v !== null && k === 'association_strengths') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.textContent = `${rid} (${w})`;
                        a.className = 'ref-link';
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });
                }
                else {
                    tdV.textContent = (typeof v === 'object') ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });
            detailPanel.appendChild(tbl);
        }

        //////////////////////////////////////////////////////////////////////
        // CHAIN REACTION
        //////////////////////////////////////////////////////////////////////
        function pulseEdge(i, baseAlpha) {
            const attr = instEdge.geometry.attributes.alpha;
            attr.setX(i, DISPLAY_CONFIG.hoverHighlightOpacity);   // brighten
            attr.needsUpdate = true;

            setTimeout(() => {                                    // restore
                attr.setX(i, baseAlpha);
                attr.needsUpdate = true;
            }, DISPLAY_CONFIG.fadeOutDuration * 1000);
        }

        function triggerChain(nodeId, depth = 0) {
            if (!nodeId || depth > DISPLAY_CONFIG.maxChainDepth) return;

            edges.forEach(e => {
                const nbr = e.source === nodeId ? e.target
                    : e.target === nodeId ? e.source
                        : null;
                if (!nbr) return;

                const delay = DISPLAY_CONFIG.chainDelay * 1000 * (depth + 1);
                const base = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);

                setTimeout(() => pulseEdge(e.index, base), delay);
                setTimeout(() => triggerChain(nbr, depth + 1), delay);
            });
        }

        //////////////////////////////////////////////////////////////////////
        // INTERACTION
        //////////////////////////////////////////////////////////////////////
        function onPointerMove(ev) {
            const r = renderer.domElement.getBoundingClientRect();
            pointer.x = (ev.clientX - r.left) / r.width * 2 - 1;
            pointer.y = -(ev.clientY - r.top) / r.height * 2 + 1;
        }
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', ev => {
            // 1) update pointer and raycast against our instanced mesh
            onPointerMove(ev);
            if (!instMesh) return;
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObject(instMesh, false)[0];
            if (!hit) return;

            // 2) figure out which node was clicked
            const idx = hit.instanceId;
            const ctxId = [...nodeMap.entries()]
                .find(([_, n]) => n._instanceIndex === idx)[0];
            hovered = selectedId = ctxId;

            // 3) raw JSON in the hover pane
            const obj = nodeMap.get(ctxId).data;
            selPane.textContent = JSON.stringify(obj, null, 2);

            // 4) build detail table (with decay on references)
            detailPanel.innerHTML = '';
            const ts0 = parseTimestamp(obj.timestamp).getTime();
            const tbl = document.createElement('table');

            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td'); tdK.textContent = k;
                const tdV = document.createElement('td');

                if (k === 'references' && Array.isArray(v)) {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = rid;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        // compute decay if we know that node
                        const ref = nodeMap.get(rid);
                        if (ref) {
                            const deltaMs = ts0 - parseTimestamp(ref.data.timestamp).getTime();
                            const days = deltaMs / (1000 * 60 * 60 * 24);
                            const decay = Math.exp(-days / 7).toFixed(2);
                            const span = document.createElement('span');
                            span.style.marginLeft = '6px';
                            span.textContent = `(decay: ${decay})`;
                            a.appendChild(span);
                        }
                        tdV.appendChild(a);
                    });

                } else if (k === 'association_strengths' && typeof v === 'object') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = `${rid} (${w})`;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = (typeof v === 'object') ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });

            detailPanel.appendChild(tbl);

            // 5) pulse the reference chain
            triggerChain(ctxId, 0);
        });



        function buildTraversalPath(id) {
            traversalPath = [id];
            let cur = id;
            while (true) {
                const refs = nodeMap.get(cur).data.references || [];
                if (!refs[0] || !nodeMap.has(refs[0])) break;
                cur = refs[0];
                traversalPath.push(cur);
            }
            pathIndex = 0;
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') {
                typeSel.selectedIndex = Math.max(0, typeSel.selectedIndex - 1);
                applyFilters();
            } else if (e.key === 'ArrowRight') {
                typeSel.selectedIndex = Math.min(typeSel.options.length - 1, typeSel.selectedIndex + 1);
                applyFilters();
            } else if (e.key === 'ArrowUp' && traversalPath.length) {
                pathIndex = Math.max(0, pathIndex - 1);
                tweenToNode(traversalPath[pathIndex]);
            } else if (e.key === 'ArrowDown' && traversalPath.length) {
                pathIndex = Math.min(traversalPath.length - 1, pathIndex + 1);
                tweenToNode(traversalPath[pathIndex]);
            }
        });

        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        typeSel.addEventListener('change', applyFilters);

        /********************************************************************
         *  Animation loop  (COMPLETE, NO OMISSIONS)
         *******************************************************************/
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // ── global upward drift ──────────────────────────────────────────
            const nowDrift = Date.now();
            const dt = nowDrift - lastDriftT;
            yScrollOffset += dt / LAYOUT_CONFIG.msPerUnit;
            lastDriftT = nowDrift;
            graphGroup.position.y = yScrollOffset;

            // ── camera tween ────────────────────────────────────────────────
            if (cameraTween) {
                const t = Math.min((performance.now() - cameraTween.start) /
                    cameraTween.duration, 1);
                camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, t);
                controls.target.lerpVectors(cameraTween.fromTarget,
                    cameraTween.toTarget, t);
                if (t >= 1) cameraTween = null;
            }

            // ── hover handling ──────────────────────────────────────────────
            if (instMesh) {
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObject(instMesh, false)[0];

                if (hit) {
                    const newIdx = hit.instanceId;
                    if (hoveredIdx !== newIdx) {
                        hoveredIdx = newIdx;

                        const found = [...nodeMap.entries()]
                            .find(([, n]) => n._instanceIndex === newIdx);

                        if (!found) {
                            hoveredIdx = null;
                            hovered = null;
                        } else {
                            const [ctxId, node] = found;
                            hovered = ctxId;

                            // JSON preview
                            selPane.textContent = JSON.stringify(node.data, null, 2);

                            // node emissive flash
                            const mat = node.mesh.material;
                            mat.emissive = new THREE.Color(0xffffff);
                            mat.emissiveIntensity = 1;
                            setTimeout(() => mat.emissiveIntensity = 0,
                                DISPLAY_CONFIG.fadeOutDuration * 1000);

                            // edge pulse chain
                            triggerChain(ctxId, 0);
                        }
                    }
                } else {
                    hoveredIdx = null;
                    hovered = null;
                }
            }

            // ── hovered-change emissive reset (re-safety) ───────────────────
            if (hovered !== previousHoveredId) {
                previousHoveredId = hovered;
                nodeMap.forEach(n => {
                    if (n.mesh) n.mesh.material.emissiveIntensity = 0;
                });
            }

            // ── final render ────────────────────────────────────────────────
            renderer.render(scene, camera);
        }
        // poll for new lines
        setInterval(() => {
            fetch(getContextFileUrl(true), { cache: 'no-store' })
                .then(r => r.text())
                .then(txt => {
                    const all = txt.trim().split(/\r?\n/);
                    if (all.length > prevCount) {
                        loadGraph();
                    }
                })
                .catch(console.error);
        }, 5000);

        // first load + start loop
        loadGraph();
        animate();

        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>

</html>