<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Context Graph Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: Arial, Helvetica, sans-serif;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 10;
        }

        #ui label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-right: 4px;
        }

        #ui select,
        #ui button {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 2px 6px;
            font-size: 0.9rem;
        }

        #selectednode {
            position: fixed;
            top: 3em;
            right: 0;
            width: 30%;
            max-width: 300px;
            height: 40%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            padding: 8px;
            font-size: 0.8rem;
            border-top-left-radius: 6px;
            box-sizing: border-box;
            white-space: pre-wrap;
            z-index: 9;
        }

        #detailPanel {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 30%;
            max-width: 300px;
            height: 40%;
            overflow: auto;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            padding: 8px;
            font-size: 0.8rem;
            border-top-right-radius: 6px;
            box-sizing: border-box;
            z-index: 9;
        }

        #detailPanel table {
            width: 100%;
            border-collapse: collapse;
        }

        #detailPanel td {
            padding: 4px;
            border-bottom: 1px solid #444;
            vertical-align: top;
        }

        #detailPanel td:first-child {
            font-weight: bold;
            width: 30%;
        }

        a.ref-link {
            color: #6cf;
            text-decoration: underline;
            cursor: pointer;
            margin-right: 6px;
        }

        canvas {
            display: block;
        }
    </style>

    <!-- import map for three.js -->
    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
      "three/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>
</head>

<body>
    <!-- ─── CONTROL BAR ─────────────────────────────────────────────────── -->
    <div id="ui">
        <label for="fileSelector">File:</label>
        <select id="fileSelector">\
        </select>

        <label for="ageFilter">Age window:</label>
        <select id="ageFilter">
            <option value="all">All</option>
            <option value="h1">Last hour</option>
            <option value="d1">Last 24 h</option>
            <option value="w1">Last 7 days</option>
            <option value="m1">Last 30 days</option>
        </select>

        <label for="typeFilter">Type / Tag:</label>
        <select id="typeFilter">
            <option value="all">All</option>
        </select>

        <button id="timeToggle">Time Mode</button>
    </div>

    <!-- ─── HOVER JSON PANE ─────────────────────────────────────────────── -->
    <div id="selectednode">// Hover or click a node…</div>

    <!-- ─── DETAIL TABLE PANEL ─────────────────────────────────────────── -->
    <div id="detailPanel"></div>

    <!-- ─── THREE.JS + LOGIC ─────────────────────────────────────────────── -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/OrbitControls';

        //////////////////////////////////////////////////////////////////////
        // CONFIG
        //////////////////////////////////////////////////////////////////////
        const LAYOUT_CONFIG = {
            msPerUnit: 1000 * 60,   // 1 min realtime = 1 Y-unit
            maxXZRadius: 500,
            minSphereY: 0
        };
        const DISPLAY_CONFIG = {
            sphereRadius: 5,
            sphereSegments: 3,
            lineBaseOpacity: 0.05,
            hoverHighlightOpacity: 0.5,
            chainDelay: 2,
            maxChainDepth: 3,
            fadeOutDuration: 1
        };

        //////////////////////////////////////////////////////////////////////
        // UI & STATE
        //////////////////////////////////////////////////////////////////////
        const fileSelector = document.getElementById('fileSelector');

        const ageSel = document.getElementById('ageFilter');
        const typeSel = document.getElementById('typeFilter');
        const timeToggle = document.getElementById('timeToggle');
        const selPane = document.getElementById('selectednode');
        const detailPanel = document.getElementById('detailPanel');

        const MAX_NODES = 5000;

        let pickableMeshes = [];
        let visibleMeshes = [];

        let nodeMap = new Map();
        let edges = [];
        let prevCount = 0;
        let timeMode = false;
        let selectedId = null;
        let traversalPath = [], pathIndex = 0;
        let previousHoveredId = null;
        let cameraTween = null;
        let hueMapCurrent = {};   // component → hue (0-1)
        let maxConnCurrent = 1;    // highest connectivity in the dataset

        // ←── Add this so instMesh is visible everywhere ──→
        let instMesh = null;
        let hovered = null;
        let hoveredIdx = null;


        // ←── PICKABLE INSTANCES SETUP ──→
        pickableMeshes.length = 0;
        const comps = [...new Set([...nodeMap.values()].map(n => n.data.component))];
        const hueMap = Object.fromEntries(comps.map((c, i) => [c, i / comps.length]));

        function getContextFileUrl(cacheBust = false) {
            let fn = fileSelector.value;
            if (!/^context(?:_-?\d+)?\.jsonl$/.test(fn)) fn = 'context.jsonl';
            return `http://0.0.0.0:8000/${fn}` + (cacheBust ? `?_=${Date.now()}` : '');
        }
        async function populateFileSelector() {
            try {
                const res = await fetch('/', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const txt = await res.text();
                let files = [];

                // 1) try JSON
                try {
                    const arr = JSON.parse(txt);
                    if (Array.isArray(arr)) {
                        files = arr;
                    } else {
                        throw new Error('JSON is not an array');
                    }
                } catch (jsonErr) {
                    console.warn('Could not parse /files as JSON, falling back to HTML scrape:', jsonErr);
                    // 2) fallback — pull href="context_....jsonl"
                    const regex = /href="(context(?:_-?\d+)?\.jsonl)"/g;
                    let m;
                    while ((m = regex.exec(txt))) {
                        files.push(m[1]);
                    }
                }

                // 3) dedupe & filter
                const unique = Array.from(new Set(files))
                    .filter(f => /^context(?:_-?\d+)?\.jsonl$/.test(f));

                // 4) rebuild the <select>
                fileSelector.innerHTML = unique
                    .map(f => `<option value="${f}">${f}</option>`)
                    .join('');

            } catch (err) {
                console.warn('populateFileSelector failed; keeping existing <option>s:', err);
                // leave whatever was in <select> alone
            }
        }

        // wire it up:
        fileSelector.addEventListener('change', () => loadGraph());

        // on startup:
        populateFileSelector()
            .then(() => loadGraph(fileSelector.value))
            .catch(() => {
                /* ignore—populateFileSelector already logged */
                loadGraph(fileSelector.value);
            });
        // ——— REPLACEMENT ———
        let isBuilding = false;
        //////////////////////////////////////////////////////////////////////////
        // BATCHED NODE CREATION
        //////////////////////////////////////////////////////////////////////////

        // break up large inserts into ~500-item chunks so the browser stays responsive
        async function batchAddNodes(objects) {
            isBuilding = true;
            const chunkSize = 500;
            for (let i = 0; i < objects.length; i += chunkSize) {
                const batch = objects.slice(i, i + chunkSize);
                addNodes(batch);
                // let the browser breathe
                await new Promise(r => requestAnimationFrame(r));
            }
            isBuilding = false;
        }

        function addNodes(objs) {
            const now = Date.now(),
                maxConn = computeMaxConnectivity();

            // ------------------------------------------------------------------
            // Build ONE InstancedMesh the first time we enter this function.
            // Every subsequent batch just re-uses the same mesh.
            // ------------------------------------------------------------------
            if (!instMesh) {
                const sphereGeo = new THREE.SphereGeometry(
                    DISPLAY_CONFIG.sphereRadius,
                    DISPLAY_CONFIG.sphereSegments,
                    DISPLAY_CONFIG.sphereSegments
                );

                const sphereMat = new THREE.MeshLambertMaterial({
                    vertexColors: true,
                    emissive: 0x000000,
                    emissiveIntensity: 1
                });

                instMesh = new THREE.InstancedMesh(sphereGeo, sphereMat, MAX_NODES);
                instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                // colour buffer (one per instance)
                const colorAttr = new THREE.InstancedBufferAttribute(
                    new Float32Array(MAX_NODES * 3),
                    3
                );
                colorAttr.setUsage(THREE.DynamicDrawUsage);
                instMesh.geometry.setAttribute('color', colorAttr);
                instMesh.instanceColor = colorAttr;

                scene.add(instMesh);

                // so the rest of the code can find the mesh later
                nodeMap.forEach(n => (n.mesh = instMesh));
            }
            // 1) compute positions & connectivity
            objs.forEach(o => {
                if (nodeMap.has(o.context_id)) return;
                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;
                const pos = new THREE.Vector3();
                pos.y = Math.max(
                    LAYOUT_CONFIG.minSphereY,
                    (now - parseTimestamp(o.timestamp).getTime())
                    / LAYOUT_CONFIG.msPerUnit
                );
                const norm = 1 - (conn / maxConn),
                    radius = norm * LAYOUT_CONFIG.maxXZRadius,
                    angle = Math.random() * Math.PI * 2;
                pos.x = Math.cos(angle) * radius;
                pos.z = Math.sin(angle) * radius;
                nodeMap.set(o.context_id, { data: o, pos, connectivity: conn, mesh: null });
            });

            // — Build hue map before using it —
            const compsLocal = [
                ...new Set(
                    [...nodeMap.values()].map(n => n.data.component)
                )
            ];
            const hueMapLocal = Object.fromEntries(
                compsLocal.map((c, i) => [c, compsLocal.length > 0 ? i / compsLocal.length : 0])
            );
            hueMapCurrent = hueMapLocal;
            maxConnCurrent = maxConn;
            // 2) Sphere instanced mesh
            const sphereGeo = new THREE.SphereGeometry(
                DISPLAY_CONFIG.sphereRadius,
                DISPLAY_CONFIG.sphereSegments,
                DISPLAY_CONFIG.sphereSegments
            );
            const sphereMat = new THREE.MeshLambertMaterial({
                vertexColors: true,
                emissive: 0x000000,   // start dark
                emissiveIntensity: 1
            });
            instMesh = new THREE.InstancedMesh(sphereGeo, sphereMat, MAX_NODES);
            instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            // allocate one big InstancedBufferAttribute…
            const colorAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(MAX_NODES * 3),
                3
            );
            colorAttr.setUsage(THREE.DynamicDrawUsage);
            // …and bind it as the 'color' attribute so the material picks it up
            instMesh.geometry.setAttribute('color', colorAttr);
            // keep a reference so the rest of your code that does setXYZ works unchanged:
            instMesh.instanceColor = colorAttr;

            scene.add(instMesh);

            // let applyFilters() work
            nodeMap.forEach(n => n.mesh = instMesh);

            // 3) Populate spheres
            const color = new THREE.Color();
            let idx = 0;
            nodeMap.forEach(n => {
                if (idx >= MAX_NODES) return;
                instMesh.setMatrixAt(idx, new THREE.Matrix4().setPosition(n.pos));

                const hue = hueMapLocal[n.data.component] || 0;
                const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                instMesh.instanceColor.setXYZ(
                    idx,
                    ...color.setHSL(hue, sat, 0.5).toArray()
                );
                n._instanceIndex = idx;
                idx++;
            });
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // 4) Raycastable list & override colors
            pickableMeshes.length = 0;
            let pickIdx = 0;
            nodeMap.forEach(n => {
                if (pickIdx >= MAX_NODES) return;
                n._instanceIndex = pickIdx;
                pickableMeshes.push(instMesh);
                const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                const [r, g, b] = new THREE.Color()
                    .setHSL(hueMapCurrent[n.data.component] || 0, sat, 0.5)
                    .toArray();
                instMesh.instanceColor.setXYZ(pickIdx, r, g, b);
                pickIdx++;
            });
            instMesh.instanceColor.needsUpdate = true;
            instMesh.instanceMatrix.needsUpdate = true;

            // 5) Efficiently batch edges into your single LineSegments
            edges.length = 0;
            let posOffset = 0, alphaOffset = 0, segIndex = 0;
            nodeMap.forEach((n, sourceId) => {
                const conns = new Map();
                (n.data.references || []).forEach(rid => conns.set(rid, 1));
                Object.entries(n.data.association_strengths || {})
                    .forEach(([rid, w]) =>
                        conns.set(rid, Math.max(conns.get(rid) || 0, w))
                    );
                conns.forEach((w, targetId) => {
                    const tgt = nodeMap.get(targetId);
                    if (!tgt) return;
                    const baseAlpha = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, w);
                    // position pair
                    edgePosArray[posOffset++] = n.pos.x;
                    edgePosArray[posOffset++] = n.pos.y;
                    edgePosArray[posOffset++] = n.pos.z;
                    edgePosArray[posOffset++] = tgt.pos.x;
                    edgePosArray[posOffset++] = tgt.pos.y;
                    edgePosArray[posOffset++] = tgt.pos.z;
                    // alpha pair
                    edgeAlphaArray[alphaOffset++] = baseAlpha;
                    edgeAlphaArray[alphaOffset++] = baseAlpha;
                    edges.push({
                        source: sourceId,
                        target: targetId,
                        weight: Math.min(1, w),
                        index: segIndex++
                    });
                });
            });
            edgeGeometry.attributes.position.needsUpdate = true;
            edgeGeometry.attributes.alpha.needsUpdate = true;
            edgeGeometry.setDrawRange(0, posOffset / 3);
        }

        // recompute max connectivity once per batch
        function computeMaxConnectivity() {
            return Math.max(
                1,
                ...[...nodeMap.values()].map(n => n.connectivity)
            );
        }

        // initial full load with verbose logging
        async function loadGraph() {
            console.log('[loadGraph] starting full graph load from', getContextFileUrl(false));
            clearScene();            // << already existed, keep
            hovered = hoveredIdx = null;   // << add this line
            prevCount = 0;
            try {
                const res = await fetch(getContextFileUrl(true));
                const txt = await res.text();
                const lines = txt.trim().split(/\r?\n/);
                console.log(`[loadGraph] fetched ${lines.length} lines`);
                prevCount = lines.length;

                const objs = lines.map((l, i) => {
                    try {
                        return JSON.parse(l);
                    } catch (err) {
                        console.error(`[loadGraph] JSON.parse error at line ${i}:`, err, l);
                        return null;
                    }
                }).filter(Boolean);
                console.log('[loadGraph] parsed objects:', objs);

                await batchAddNodes(objs);
                populateTypeFilter([...nodeMap.values()].map(n => n.data));
                applyFilters();
                console.log('[loadGraph] batchAddNodes complete');
            } catch (err) {
                console.error('[loadGraph] error loading graph:', err);
            }
        }

        // incremental updater with verbose logging and dynamic scene update
        async function pollForNew() {
            console.log('[pollForNew] checking for updates...');
            try {
                const res = await fetch(getContextFileUrl(true), { cache: 'no-store' });
                const txt = await res.text();
                const lines = txt.trim().split(/\r?\n/);
                console.log(`[pollForNew] total lines: ${lines.length}, prevCount: ${prevCount}`);

                if (lines.length > prevCount && !isBuilding) {
                    const newLines = lines.slice(prevCount);
                    console.log(`[pollForNew] detected ${newLines.length} new line(s)`);

                    const added = newLines.map((l, i) => {
                        try {
                            const obj = JSON.parse(l);
                            console.log(`[pollForNew] parsed new object ${i}:`, obj);
                            return obj;
                        } catch (err) {
                            console.error(`[pollForNew] parse error for new line ${i}:`, err, l);
                            return null;
                        }
                    }).filter(Boolean);

                    prevCount = lines.length;
                    console.log('[pollForNew] calling batchAddNodes with new objects');
                    await batchAddNodes(added);
                    populateTypeFilter([...nodeMap.values()].map(n => n.data));
                    applyFilters();
                    console.log('[pollForNew] batchAddNodes complete');

                    // refresh filters & highlight newest
                    applyFilters();
                    if (added.length) {
                        console.log('[pollForNew] triggering chain on', added[added.length - 1].context_id);
                        triggerChain(added[added.length - 1].context_id, 0);
                    }
                }
            } catch (err) {
                console.error('[pollForNew] fetch or parse error:', err);
            }
        }
        setInterval(pollForNew, 5000);

        // ─── BUILD SCENE ──────────────────────────────────────────────────
        function buildScene(objects) {
            // sort by timestamp (newest first)
            objects.sort((a, b) =>
                parseTimestamp(b.timestamp) - parseTimestamp(a.timestamp)
            );

            const now = Date.now();
            nodeMap.clear();

            // index + compute connectivity
            objects.forEach(o => {
                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;
                nodeMap.set(o.context_id, {
                    data: o,
                    mesh: null,
                    pos: new THREE.Vector3(),
                    connectivity: conn
                });
            });

            // layout: Y = age, XZ scatter by connectivity
            const maxConn = Math.max(...[...nodeMap.values()].map(n => n.connectivity), 1);
            nodeMap.forEach(n => {
                const age = now - parseTimestamp(n.data.timestamp).getTime();
                n.pos.y = Math.max(LAYOUT_CONFIG.minSphereY, age / LAYOUT_CONFIG.msPerUnit);
                const norm = 1 - (n.connectivity / maxConn);
                const r = norm * LAYOUT_CONFIG.maxXZRadius;
                const a = Math.random() * Math.PI * 2;
                n.pos.x = Math.cos(a) * r;
                n.pos.z = Math.sin(a) * r;
            });

            nodeMap.forEach((n, id) => {
                const conns = new Map();
                (n.data.references || []).forEach(rid => conns.set(rid, 1));
                Object.entries(n.data.association_strengths || {}).forEach(([rid, w]) => {
                    conns.set(rid, Math.max(conns.get(rid) || 0, w));
                });
                conns.forEach((w, oid) => {
                    const tgt = nodeMap.get(oid);
                    if (!tgt) return;
                    const mat = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, w)
                    });
                    const geo = new THREE.BufferGeometry().setFromPoints([n.pos, tgt.pos]);
                    const line = new THREE.Line(geo, mat);
                    line.visible = false;
                    scene.add(line);
                    edges.push({ line, source: id, target: oid, weight: Math.min(1, w) });
                });
            });

            // ←── BUFFERED LINESEGMENTS UPDATE ──→
            edges.forEach((e, i) => {
                const a = nodeMap.get(e.source).pos;
                const b = nodeMap.get(e.target).pos;
                const idx3 = i * 6;  // two vertices × 3 floats
                const idx1 = i * 2;  // two alpha values
                edgePosArray.set([a.x, a.y, a.z, b.x, b.y, b.z], idx3);
                edgeAlphaArray.set([e.weight, e.weight], idx1);
            });
            edgeGeometry.attributes.position.needsUpdate = true;
            edgeGeometry.attributes.alpha.needsUpdate = true;

            // ←──────────────────────────────────→

            // refresh filters/UI
            populateTypeFilter(objects);
            applyFilters();
        }

        // ─── INITIALIZE ──────────────────────────────────────────────────
        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        typeSel.addEventListener('change', applyFilters);
        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        populateFileSelector()
            .then(() => loadGraph());

        //////////////////////////////////////////////////////////////////////
        // THREE.JS SETUP
        //////////////////////////////////////////////////////////////////////
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2e6);
        camera.position.set(0, 500, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(1, 1, 1);
        scene.add(keyLight);


        // —— EDGE INSTANCED LINESEGMENTS SETUP ——
        const MAX_EDGES = 20000;
        const edgePosArray = new Float32Array(MAX_EDGES * 2 * 3);
        const edgeAlphaArray = new Float32Array(MAX_EDGES * 2);

        const edgeGeometry = new THREE.BufferGeometry();
        edgeGeometry.setAttribute('position', new THREE.BufferAttribute(edgePosArray, 3));
        edgeGeometry.setAttribute('alpha', new THREE.BufferAttribute(edgeAlphaArray, 1));

        // NOTE: Three.js expects ShaderMaterials to have a standard set of uniforms
        // (opacity, diffuse, emissive, map, lightMap, specularMap, alphaMap, envMap).
        // Here we stub them all out so nothing is ever undefined.

        const edgeMaterial = new THREE.ShaderMaterial({
            transparent: true,
            // stub out the full set of common uniforms Three.js expects
            uniforms: {
                opacity: { value: DISPLAY_CONFIG.lineBaseOpacity },
                diffuse: { value: new THREE.Color(1, 1, 1) },
                emissive: { value: new THREE.Color(0, 0, 0) },
                map: { value: null },
                lightMap: { value: null },
                specularMap: { value: null },
                alphaMap: { value: null },
                envMap: { value: null }
            },
            vertexShader: /* glsl */`
    attribute float alpha;
    varying float vAlpha;
    void main() {
      vAlpha = alpha;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
            fragmentShader: /* glsl */`
    varying float vAlpha;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha);
    }`
        });

        const edgeMesh = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        scene.add(edgeMesh);
        edgeMesh.visible = true;


        //////////////////////////////////////////////////////////////////////
        // HELPERS
        //////////////////////////////////////////////////////////////////////
        function parseTimestamp(ts) {
            const y = +ts.slice(0, 4), m = +ts.slice(4, 6) - 1, d = +ts.slice(6, 8),
                hh = +ts.slice(9, 11), mm = +ts.slice(11, 13), ss = +ts.slice(13, 15);
            return new Date(Date.UTC(y, m, d, hh, mm, ss));
        }
        function unixNow() { return Date.now(); }

        function clearScene() {
            // ── remove **all** InstancedMeshes that might still be in the scene
            scene.children
                .filter(o => o.isInstancedMesh)
                .forEach(m => {
                    scene.remove(m);
                    m.geometry.dispose();
                    m.material.dispose();
                });
            instMesh = null;

            // ── reset the shared edge LineSegments buffer
            edgeGeometry.setDrawRange(0, 0);
            edgeGeometry.attributes.position.needsUpdate = true;
            edgeGeometry.attributes.alpha.needsUpdate = true;

            // ── wipe JS-side state
            nodeMap.clear();
            edges.length = 0;
            pickableMeshes.length = 0;
            hovered = null;
            hoveredIdx = null;
            selectedId = null;
            prevCount = 0;

            // ── clear UI
            selPane.textContent = '// Hover or click a node…';
            detailPanel.innerHTML = '';
        }


        //////////////////////////////////////////////////////////////////////
        // FILTERS
        //////////////////////////////////////////////////////////////////////
        function populateTypeFilter(objs) {
            const bucket = new Set();
            objs.forEach(o => {
                bucket.add('domain:' + o.domain);
                bucket.add('component:' + o.component);
                (o.tags || []).forEach(t => bucket.add('tag:' + t));
            });
            typeSel.innerHTML = '<option value="all">All</option>';
            [...bucket].sort().forEach(k => {
                const opt = document.createElement('option');
                opt.value = k; opt.textContent = k;
                typeSel.appendChild(opt);
            });
        }
        // ——— applyFilters() for the single InstancedMesh + edge visibility ———
        function applyFilters() {
            const now = unixNow();
            const ageMax = ({ h1: 3600e3, d1: 86400e3, w1: 86400e3 * 7, m1: 86400e3 * 30 }[ageSel.value]) || 0;
            const pickVal = typeSel.value;        // "all" or "tag:foo" / "domain:bar" / "component:baz"
            const color = new THREE.Color();

            let writeIdx = 0;                     // next slot in the InstancedMesh
            const liveIds = new Set();       // survives age-filter
            const selectedIds = new Set();       // also matches type / tag

            // pass ① — write *every* age-visible node, marking selected vs dim
            nodeMap.forEach((n, ctxId) => {
                // ❶ age filter (nodes too old are *hidden*)
                if (ageMax) {
                    const age = now - parseTimestamp(n.data.timestamp).getTime();
                    if (age > ageMax) return;               // skip entirely
                }

                // node survives age filter
                liveIds.add(ctxId);

                // ❷ does it satisfy the drop-down?
                let isPick = true;
                if (pickVal !== 'all') {
                    const [k, v] = pickVal.split(':');
                    if (k === 'domain') isPick = n.data.domain === v;
                    if (k === 'component') isPick = n.data.component === v;
                    if (k === 'tag') isPick = (n.data.tags || []).includes(v);
                }
                if (isPick) selectedIds.add(ctxId);

                // ❸ write instance (matrix unchanged)
                instMesh.setMatrixAt(writeIdx, new THREE.Matrix4().setPosition(n.pos));

                // primary colour
                const hue = hueMapCurrent[n.data.component] || 0;
                const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                const lightness = isPick ? 0.5 : 0.25;           // 100 % vs 50 %
                instMesh.instanceColor.setXYZ(
                    writeIdx,
                    ...color.setHSL(hue, sat, lightness).toArray()
                );

                n._instanceIndex = writeIdx;
                writeIdx++;
            });

            instMesh.count = writeIdx;                 // draw only what we rewrote
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // pass ② — edge alpha: hide if age-filtered, dim if non-selected
            edges.forEach(e => {
                const bothLive = liveIds.has(e.source) && liveIds.has(e.target);
                const bothSelected = selectedIds.has(e.source) && selectedIds.has(e.target);
                const off = e.index * 2;
                const alpha =
                    !bothLive ? 0 :                             // completely hidden
                        bothSelected ? DISPLAY_CONFIG.lineBaseOpacity * e.weight :   // full
                            DISPLAY_CONFIG.lineBaseOpacity * e.weight * 0.5; // 50 %
                edgeAlphaArray[off] = alpha;
                edgeAlphaArray[off + 1] = alpha;
            });
            edgeGeometry.attributes.alpha.needsUpdate = true;

            // pass ③ — reset hover if it just became invisible
            if (hovered && !liveIds.has(hovered)) {
                hovered = hoveredIdx = null;
                selPane.textContent = '// Hover or click a node…';
            }
        }



        //////////////////////////////////////////////////////////////////////
        // CAMERA DOLLY / TWEEN
        //////////////////////////////////////////////////////////////////////
        function tweenToNode(id) {
            const n = nodeMap.get(id);
            if (!n) return;
            const fromPos = camera.position.clone();
            const fromTarget = controls.target.clone();
            const toPos = new THREE.Vector3(n.pos.x, n.pos.y + 10, n.pos.z + 30);
            const toTarget = n.pos.clone();
            cameraTween = {
                fromPos, toPos,
                fromTarget, toTarget,
                start: performance.now(),
                duration: 600
            };
        }

        //////////////////////////////////////////////////////////////////////
        // DETAIL PANEL
        //////////////////////////////////////////////////////////////////////
        function populateDetail(id) {
            const obj = nodeMap.get(id).data;
            detailPanel.innerHTML = '';
            const tbl = document.createElement('table');
            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                tdK.textContent = k;
                const tdV = document.createElement('td');

                // references array
                if (Array.isArray(v) && k === 'references') {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.textContent = rid;
                        a.className = 'ref-link';
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });
                }
                // association_strengths object
                else if (typeof v === 'object' && v !== null && k === 'association_strengths') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.textContent = `${rid} (${w})`;
                        a.className = 'ref-link';
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });
                }
                else {
                    tdV.textContent = (typeof v === 'object') ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });
            detailPanel.appendChild(tbl);
        }

        //////////////////////////////////////////////////////////////////////
        // CHAIN REACTION
        //////////////////////////////////////////////////////////////////////
        function triggerChain(nodeId, depth = 0) {
            if (!nodeId || depth > DISPLAY_CONFIG.maxChainDepth) return;

            edges.forEach(e => {
                // figure out if this edge touches our node
                const nbr = e.source === nodeId ? e.target
                    : e.target === nodeId ? e.source
                        : null;
                if (!nbr) return;

                // schedule the “pulse”
                const delayMs = DISPLAY_CONFIG.chainDelay * 1000 * (depth + 1);
                setTimeout(() => {
                    // highlight in the alpha buffer
                    const off = e.index * 2;
                    edgeAlphaArray[off] = DISPLAY_CONFIG.hoverHighlightOpacity;
                    edgeAlphaArray[off + 1] = DISPLAY_CONFIG.hoverHighlightOpacity;
                    edgeGeometry.attributes.alpha.needsUpdate = true;

                    // reset after fadeOutDuration
                    setTimeout(() => {
                        const base = DISPLAY_CONFIG.lineBaseOpacity * e.weight;
                        edgeAlphaArray[off] = base;
                        edgeAlphaArray[off + 1] = base;
                        edgeGeometry.attributes.alpha.needsUpdate = true;
                    }, DISPLAY_CONFIG.fadeOutDuration * 1000);
                }, delayMs);

                // recurse to next depth
                setTimeout(() => triggerChain(nbr, depth + 1),
                    DISPLAY_CONFIG.chainDelay * 1000 * (depth + 1));
            });
        }

        //////////////////////////////////////////////////////////////////////
        // INTERACTION
        //////////////////////////////////////////////////////////////////////
        function onPointerMove(ev) {
            const r = renderer.domElement.getBoundingClientRect();
            pointer.x = (ev.clientX - r.left) / r.width * 2 - 1;
            pointer.y = -(ev.clientY - r.top) / r.height * 2 + 1;
        }
        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', ev => {
            // 1) update pointer and raycast against our instanced mesh
            onPointerMove(ev);
            if (!instMesh) return;
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObject(instMesh, false)[0];
            if (!hit) return;

            // 2) figure out which node was clicked
            const idx = hit.instanceId;
            const ctxId = [...nodeMap.entries()]
                .find(([_, n]) => n._instanceIndex === idx)[0];
            hovered = selectedId = ctxId;

            // 3) raw JSON in the hover pane
            const obj = nodeMap.get(ctxId).data;
            selPane.textContent = JSON.stringify(obj, null, 2);

            // 4) build detail table (with decay on references)
            detailPanel.innerHTML = '';
            const ts0 = parseTimestamp(obj.timestamp).getTime();
            const tbl = document.createElement('table');

            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td'); tdK.textContent = k;
                const tdV = document.createElement('td');

                if (k === 'references' && Array.isArray(v)) {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = rid;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        // compute decay if we know that node
                        const ref = nodeMap.get(rid);
                        if (ref) {
                            const deltaMs = ts0 - parseTimestamp(ref.data.timestamp).getTime();
                            const days = deltaMs / (1000 * 60 * 60 * 24);
                            const decay = Math.exp(-days / 7).toFixed(2);
                            const span = document.createElement('span');
                            span.style.marginLeft = '6px';
                            span.textContent = `(decay: ${decay})`;
                            a.appendChild(span);
                        }
                        tdV.appendChild(a);
                    });

                } else if (k === 'association_strengths' && typeof v === 'object') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = `${rid} (${w})`;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = (typeof v === 'object') ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });

            detailPanel.appendChild(tbl);

            // 5) pulse the reference chain
            triggerChain(ctxId, 0);
        });



        function buildTraversalPath(id) {
            traversalPath = [id];
            let cur = id;
            while (true) {
                const refs = nodeMap.get(cur).data.references || [];
                if (!refs[0] || !nodeMap.has(refs[0])) break;
                cur = refs[0];
                traversalPath.push(cur);
            }
            pathIndex = 0;
        }

        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') {
                typeSel.selectedIndex = Math.max(0, typeSel.selectedIndex - 1);
                applyFilters();
            } else if (e.key === 'ArrowRight') {
                typeSel.selectedIndex = Math.min(typeSel.options.length - 1, typeSel.selectedIndex + 1);
                applyFilters();
            } else if (e.key === 'ArrowUp' && traversalPath.length) {
                pathIndex = Math.max(0, pathIndex - 1);
                tweenToNode(traversalPath[pathIndex]);
            } else if (e.key === 'ArrowDown' && traversalPath.length) {
                pathIndex = Math.min(traversalPath.length - 1, pathIndex + 1);
                tweenToNode(traversalPath[pathIndex]);
            }
        });

        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        typeSel.addEventListener('change', applyFilters);
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 1) camera tween
            if (cameraTween) {
                const t = Math.min((performance.now() - cameraTween.start) / cameraTween.duration, 1);
                camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, t);
                controls.target.lerpVectors(cameraTween.fromTarget, cameraTween.toTarget, t);
                if (t >= 1) cameraTween = null;
            }

            if (instMesh && typeof hoveredIdx !== 'undefined') {
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObject(instMesh, false)[0];

                if (hit) {
                    const newIdx = hit.instanceId;
                    if (hoveredIdx !== newIdx) {
                        hoveredIdx = newIdx;

                        // safely look up the entry
                        const found = [...nodeMap.entries()]
                            .find(([, n]) => n._instanceIndex === newIdx);
                        if (!found) {
                            // nothing matched, clear state
                            hoveredIdx = null;
                            hovered = null;
                            return;
                        }

                        const [ctxId, node] = found;
                        hovered = ctxId;

                        // update hover pane
                        selPane.textContent = JSON.stringify(node.data, null, 2);

                        // flash emissive
                        const mat = node.mesh.material;
                        mat.emissive = new THREE.Color(0xffffff);
                        mat.emissiveIntensity = 1;
                        setTimeout(
                            () => mat.emissiveIntensity = 0,
                            DISPLAY_CONFIG.fadeOutDuration * 1000
                        );

                        // pulse chain
                        triggerChain(ctxId, 0);
                    }
                } else {
                    hoveredIdx = null;
                    hovered = null;
                }
            }



            // 3) update edge alphas in a single pass
            edges.forEach(e => {
                const base = DISPLAY_CONFIG.lineBaseOpacity * e.weight;
                const off = e.index * 2;
                edgeAlphaArray[off] = base;
                edgeAlphaArray[off + 1] = base;
            });
            if (hovered) {
                edges.forEach(e => {
                    if (e.source === hovered || e.target === hovered) {
                        const off = e.index * 2;
                        edgeAlphaArray[off] = DISPLAY_CONFIG.hoverHighlightOpacity;
                        edgeAlphaArray[off + 1] = DISPLAY_CONFIG.hoverHighlightOpacity;
                    }
                });
            }
            edgeGeometry.attributes.alpha.needsUpdate = true;

            // 4) emissive flash on actual hover *change*
            if (hovered !== previousHoveredId) {
                previousHoveredId = hovered;
                nodeMap.forEach(n => {
                    n.mesh.material.emissiveIntensity = 0;
                });
                if (hovered) {
                    const m = nodeMap.get(hovered).mesh;
                    m.material.emissive = new THREE.Color(0xffffff);
                    m.material.emissiveIntensity = 1;
                    setTimeout(() => m.material.emissiveIntensity = 0,
                        DISPLAY_CONFIG.fadeOutDuration * 1000);
                    triggerChain(hovered, 0);
                }
            }

            // 5) final render
            renderer.render(scene, camera);
        }
        // poll for new lines
        setInterval(() => {
            fetch(getContextFileUrl(true), { cache: 'no-store' })
                .then(r => r.text())
                .then(txt => {
                    const all = txt.trim().split(/\r?\n/);
                    if (all.length > prevCount) {
                        loadGraph();
                    }
                })
                .catch(console.error);
        }, 5000);

        // first load + start loop
        loadGraph();
        animate();

        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>

</html>