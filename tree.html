<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Context Graph Viewer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Doto:wght@100..900&display=swap');

        * {
            font-family: "Doto", sans-serif;
        }

        input,
        select,
        button,
        textarea,
        select,
        label {
            font-family: "Doto", sans-serif;
            font-style: normal;
            background: transparent !important;
            border: 1px dashed #333 !important;
            color: white !important;
            line-height: 1.75;
            font-size: 0.75rem;
            height: 2rem;
            box-sizing: border-box;
            backdrop-filter: blur(3px);
            border-top: unset !important;
            border-left: unset !important;

        }

        option {
            font-family: "Doto", sans-serif;
            font-style: normal;
            background: black !important;
            border: 1px dashed #333 !important;
            color: white !important;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            overflow: hidden;
            color: #eee;
            font-family: Arial, Helvetica, sans-serif;
        }

        #ui {
            box-sizing: border-box;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            box-sizing: border-box;
            justify-content: space-between;
            z-index: 10;
        }

        .column {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100%;
            border-radius: 6px;
        }

        #ui label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-right: 4px;
        }

        #ui select,
        #ui button {
            background: #222;
            color: #eee;
            border: 1px solid #444;
            padding: 2px 6px;
            font-size: 0.9rem;
        }

        *::-webkit-scrollbar {
            display: none;
        }

        * {
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }

        #selectednode {
            width: 0px;
            font-size: 0.5rem;
            opacity: 0.5;
            display: none;
            position: fixed;
            top: 3em;
            left: 0;
            width: auto;
            height: calc(60% - 3em);
            overflow: auto;
            padding: 8px;
            font-size: 0.8rem;
            border-top-left-radius: 6px;
            box-sizing: border-box;
            white-space: pre-wrap;
            z-index: 9;
        }

        .row {
            display: flex;
            flex-flow: wrap;
        }

        #timeindicators {

            font-family: "Doto", sans-serif;
            font-style: normal;
            background: transparent !important;
            color: white !important;
        }

        .ref-link {
            pointer-events: all !important;
        }

        #detailPanel {
            width: 0px;
            font-size: 0.5rem;
            position: fixed;
            bottom: 0;
            left: 0;
            top: 8em;
            bottom: 0;
            width: 500px;
            max-width: 50%;
            overflow: auto;
            padding: 8px;
            font-size: 0.75rem;
            border-top-right-radius: 6px;
            box-sizing: border-box;
            z-index: 9;
            display: inline-table;
            pointer-events: none;
            text-shadow: 0px 0px 2px black;
        }

        #detailPanel table {
            width: 100%;
            border-collapse: collapse;
        }

        #detailPanel td {
            vertical-align: top;
            padding-left: 0.5rem;
        }

        #detailPanel td:first-child {
            font-weight: bold;
            text-align: right;
            padding-right: 0.5rem;
            padding-left: 0rem;
            border-right: 1px dashed #555;
        }

        .sidebar-item-highlight::after {
            content: '';
            left: -0.5rem;
            width: 1px;
            height: calc(100% - 1rem);
            background: white;
            animation: expand 0.2s ease-in-out;
        }

        @keyframes expand {
            0% {
                width: 0rem;
            }

            50% {
                width: 0.25rem;
            }

            100% {
                width: 0rem;
            }
        }

        .sidebar-header {
            display: flex;
            flex-flow: column;
        }

        .sidebar-header:hover {
            background: #333;
        }

        .json-section>div {
            margin: 2px 0;
        }

        a.ref-link {
            color: #6cf;
            text-decoration: underline;
            cursor: pointer;
            margin-right: 6px;
        }

        canvas {
            display: block;
        }
    </style>

    <!-- import map for three.js -->
    <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
      "three/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>
</head>

<body>
    <!-- ─── CONTROL BAR ─────────────────────────────────────────────────── -->
    <div id="ui">
        <div class="column">

            <div class="row">
                <select id="ageFilter">
                    <option value="all">All</option>
                    <option value="h1">Last hour</option>
                    <option value="d1">Last 24 h</option>
                    <option value="w1">Last 7 days</option>
                    <option value="m1">Last 30 days</option>
                </select>

                <select id="domainFilter"></select>
                <select id="componentFilter"></select>
                <select id="semanticFilter"></select>
            </div>

            <div class="row">
                <select id="fileSelector">\
                </select> <button id="timeToggle">Time Mode</button>

            </div>

        </div>
        <div class="column">
            <div class="row">

                <div id="timeIndicators" style="background:transparent;           
border:1px solid #555; line-height:1.75!important;padding: 0.25rem; color:#fff; padding:0 0.5rem;
                        border: 1px dashed #333;border-top:unset;border-right:unset;

            height:2rem;">
                    <span id="nowTime">// <b>now</b> </span>
                    <span id="viewTime">// <b>view</b> </span>
                </div>
            </div>
        </div>
    </div>

    <!-- ─── HOVER JSON PANE ─────────────────────────────────────────────── -->
    <div id="selectednode">// Hover or click a node…</div>

    <!-- ─── DETAIL TABLE PANEL ─────────────────────────────────────────── -->
    <div id="detailPanel"></div>

    <!-- ─── SIDEBAR MODULE LIST ─────────────────────────────────────────── -->
    <div id="sidebarList" style="
           position: fixed;
           top: 2rem;
           right: 0;
           bottom: 0;
           width: 300px;
           overflow-y: auto;
           color: #eee;
           font-size: 0.75rem;
           backdrop-filter: blur(3px);
           z-index: 8;
         ">
        <!-- dynamically populated -->
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- ─── THREE.JS + LOGIC ─────────────────────────────────────────────── -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/OrbitControls';

        //////////////////////////////////////////////////////////////////////
        // CONFIG
        //////////////////////////////////////////////////////////////////////
        const LAYOUT_CONFIG = {
            // 60000 ms = 1 minute → 1 Y-unit
            msPerUnit: 10 * 1000,

            // you can speed up spawning independently of drift
            spawnFactor: 1.0,

            // you can speed up (or slow down) drift separately
            driftFactor: 1.0,

            maxXZRadius: 200,
            minSphereY: 0
        };
        const DISPLAY_CONFIG = {
            sphereRadius: 2,
            sphereSegments: 8,
            lineBaseOpacity: 0.8,
            hoverHighlightOpacity: 0.3,
            chainDelay: 200,
            maxChainDepth: 50,
            fadeOutDuration: 1000
        };

        //////////////////////////////////////////////////////////////////////
        // UI & STATE
        //////////////////////////////////////////////////////////////////////
        const nowLbl = document.getElementById('nowTime');
        const viewLbl = document.getElementById('viewTime');

        /* wheel → Y-units. 0.05 ≃  0.5  sec per scroll-tick with msPerUnit = 10 000 ms */
        const SCROLL_SPEED = 0.5;
        const fileSelector = document.getElementById('fileSelector');

        const ageSel = document.getElementById('ageFilter');
        const domainSel = document.getElementById('domainFilter');
        const componentSel = document.getElementById('componentFilter');
        const semanticSel = document.getElementById('semanticFilter');

        // we'll keep a master list of all objects
        let allData = [];
        const timeToggle = document.getElementById('timeToggle');
        const selPane = document.getElementById('selectednode');
        const detailPanel = document.getElementById('detailPanel');
        const BASE_EDGE_GREY = 0.25;
        // ─── CORE STATE ───────────────────────────────────────────────────────
        let pickableMeshes = [];
        let visibleMeshes = [];
        let initialLoadDone = false;

        let freeNodeIx = 0;
        let freeEdgeIx = 0;
        let seenIds = new Set();

        let lastSize = 0;
        let lastETag = '';
        const POLL_INTERVAL = 1000;
        let scrollVelocity = 0;
        const SCROLL_ACCEL = 0.002;  // tweak: how much wheel delta becomes velocity
        const SCROLL_FRICTION = .99;   // per-frame multiplier (<1 to slow down)
        const SCROLL_DIR = -1;
        let scrollBoost = 100;
        let lastWheelDir = 0;
        let lastWheelTime = 0;

        const BOOST_INCREMENT = 50;    // how much boost you gain per rapid event
        const BOOST_DECAY = 0.75;   // how quickly boost winds down
        const BOOST_MAX = 1000;      // cap on boost multiplier
        const MAX_INSTANCES_HARD = 0xFFFF;
        const HARD_MAX_NODES = 1000;
        let prevCount = 0;
        let remoteSize = 0;
        let prevLineCount = 0;
        const LAST_KB = 16;
        const WANT_LINES = 120;          // how many recent JSON-lines we care about
        const RANGE_KB_MIN = 64;           // 1st attempt → 64 KB tail
        const RANGE_KB_MAX = 512;          // hard ceiling for the tail window
        let tailKB = RANGE_KB_MIN; // grows when we miss, shrinks when we hit
        let lastContextId = null;
        let lastOffset = 0;
        let leftover = "";    // carry over any partial line
        const OVERLAP = 1024;   // bytes to rewind so you don't cut a JSON in half
        const STORAGE_KEY = 'selectedContextFile';

        let nodeMap = new Map();
        let edges = [];

        let hueMapCurrent = {};
        let maxConnCurrent = 1;

        let cameraTween = null;
        let selectedId = null;
        let previousHoveredId = null;
        // ←── Add this so instMesh is visible everywhere ──→
        let instMesh = null;
        let instEdge = null;
        let hovered = null;
        let hoveredIdx = null;
        let yScrollOffset = 0;
        // last time we applied that drift
        let lastDriftT = Date.now();
        // ←── PICKABLE INSTANCES SETUP ──→
        pickableMeshes.length = 0;
        const comps = [...new Set([...nodeMap.values()].map(n => n.data.component))];
        const hueMap = Object.fromEntries(comps.map((c, i) => [c, i / comps.length]));
        const MS_PER_UNIT = LAYOUT_CONFIG.msPerUnit;  // ms per world‐unit, e.g. 10 000
let autoScrollEnabled = true;
const sidebar = document.getElementById('sidebarList');
sidebar.addEventListener('scroll', () => {
  const nearBottom =
    sidebar.scrollTop + sidebar.clientHeight >=
    sidebar.scrollHeight - 5;
  autoScrollEnabled = nearBottom;
});
        function getContextFileUrl(cacheBust = false) {
            const host = window.location.hostname || 'localhost';
            // trust whatever the user chose
            const fn = fileSelector.value || 'context.jsonl';
            console.log('getContextFileUrl() →', `http://${host}:8000/${fn}`);
            return `http://${host}:8000/${fn}` + (cacheBust ? `?_=${Date.now()}` : '');
        }

        async function populateFileSelector() {
            try {
                const res = await fetch(window.location.origin + '/', { cache: 'no-store' });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const txt = await res.text();
                let files = [];

                // 1) try JSON
                try {
                    const arr = JSON.parse(txt);
                    if (Array.isArray(arr)) {
                        files = arr;
                    } else {
                        throw new Error('JSON is not an array');
                    }
                } catch (jsonErr) {
                    console.warn('Could not parse / as JSON, falling back to HTML scrape:', jsonErr);
                    // 2) fallback — pull href="context_....jsonl"
                    const regex = /href="(context(?:_-?\d+)?\.jsonl)"/g;
                    let m;
                    while ((m = regex.exec(txt))) {
                        files.push(m[1]);
                    }
                }

                // 3) dedupe & filter & sort
                const unique = Array.from(new Set(files))
                    .filter(f => /^context(?:_-?\d+)?\.jsonl$/.test(f))
                    .sort();

                // 4) rebuild the <select>
                fileSelector.innerHTML = unique
                    .map(f => `<option value="${f}">${f}</option>`)
                    .join('');

                // 5) restore last selection if present
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved && unique.includes(saved)) {
                    fileSelector.value = saved;
                }

            } catch (err) {
                console.warn('populateFileSelector failed; keeping existing <option>s:', err);
            }
        }

        // call loadGraph() whenever user picks a file
        fileSelector.addEventListener('change', () => {
            localStorage.setItem(STORAGE_KEY, fileSelector.value);
            loadGraph();
        });

        // on startup: populate, restore or default, then load
        ; (async () => {
            await populateFileSelector();
            if (!localStorage.getItem(STORAGE_KEY) && fileSelector.options.length) {
                fileSelector.value = fileSelector.options[0].value;
            }
            // do the very first full load
            await loadGraph();
            // now that allData is populated, mark the sentinel
            if (allData.length) {
                lastContextId = allData[allData.length - 1].context_id;
            }
            // now start polling
            setInterval(pollForNew, POLL_INTERVAL);
        })();


        function runForceLayout() {
            // 1️⃣ build nodes & links arrays
            const nodes = [...nodeMap.entries()].map(([id, entry]) => ({
                id,
                x: entry.pos.x,
                y: entry.pos.z   // map z→y for 2D layout
            }));
            const links = edges.map(e => ({ source: e.source, target: e.target }));

            // 2️⃣ stash current positions for tweening
            const layoutTime = performance.now();
            nodeMap.forEach(entry => {
                entry.prevPos = entry.pos.clone();
            });

            // 3️⃣ run a D3 force simulation
            const sim = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(-30))
                .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(100)
                    .strength(1))
                .force('center', d3.forceCenter(0, 0))
                .stop();

            for (let i = 0; i < 200; ++i) sim.tick();

            // 4️⃣ write back new target positions
            nodes.forEach(n => {
                const entry = nodeMap.get(n.id);
                entry.pos.x = n.x;
                entry.pos.z = n.y;
                // kick off a 600 ms tween
                entry.tweenStart = layoutTime;
                entry.tweenDuration = 600;
            });

            // 5️⃣ (No immediate mesh update here – animate() will drive it)
        }

        // ─── New helper: rebuild all edges based on updated nodeMap ──────────
        function updateEdgeMeshes() {
            if (!instEdge) initEdges();

            const mat = new THREE.Matrix4();
            const axisY = new THREE.Vector3(0, 1, 0);
            let ei = 0;

            edges.forEach(e => {
                const src = nodeMap.get(e.source);
                const tgt = nodeMap.get(e.target);
                if (!src || !tgt) return;

                // compute direction & length
                const dir = new THREE.Vector3().subVectors(tgt.pos, src.pos);
                const len = dir.length();
                if (!len) return;

                // build the orientation quaternion
                const quat = new THREE.Quaternion()
                    .setFromUnitVectors(axisY, dir.clone().normalize());

                // compose the instance matrix (thin box from src → tgt)
                mat.compose(src.pos, quat, new THREE.Vector3(0.2, len, 0.2));
                instEdge.setMatrixAt(ei, mat);

                // copy the source node's color
                const srcIdx = src._instanceIndex;
                const r = instMesh.instanceColor.getX(srcIdx);
                const g = instMesh.instanceColor.getY(srcIdx);
                const b = instMesh.instanceColor.getZ(srcIdx);
                instEdge.instanceColor.setXYZ(ei, r, g, b);

                ei++;
            });

            // upload counts + attributes
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            instEdge.instanceColor.needsUpdate = true;
        }

        // 1️⃣ Build the nested list from allData after each full load
        // ─── Replacement buildSidebarList ──────────────────────────────────────
        function buildSidebarList(data) {
            const container = document.getElementById('sidebarList');
            container.innerHTML = '';

            // group by context_id
            const groups = data.reduce((acc, o) => {
                (acc[o.context_id] ??= []).push(o);
                return acc;
            }, {});

            // recursive renderer for arbitrary-depth JSON
            function renderObject(obj, parent) {
                if (obj === null || typeof obj !== 'object') {
                    // primitive → read-only input
                    let inp;
                    if (typeof obj === 'boolean') {
                        inp = document.createElement('input');
                        inp.type = 'checkbox';
                        inp.checked = obj;
                        inp.disabled = true;
                    } else if (typeof obj === 'number') {
                        inp = document.createElement('input');
                        inp.type = 'number';
                        inp.value = obj;
                        inp.readOnly = true;
                    } else {
                        inp = document.createElement('input');
                        inp.type = 'text';
                        inp.value = obj;
                        inp.readOnly = true;
                    }
                    inp.style = 'margin:2px 0; width:100%;';
                    parent.appendChild(inp);

                } else if (Array.isArray(obj)) {
                    obj.forEach((item, i) => {
                        const section = document.createElement('div');
                        section.style = 'margin-left:12px; border-left:1px solid #444; padding-left:6px;';
                        const title = document.createElement('div');
                        title.textContent = `[${i}]`;
                        title.style = 'font-weight:bold; cursor:pointer;';
                        section.appendChild(title);
                        const content = document.createElement('div');
                        content.style = 'display:none;';
                        renderObject(item, content);
                        section.appendChild(content);
                        title.onclick = () => {
                            content.style.display = content.style.display === 'none' ? 'block' : 'none';
                        };
                        parent.appendChild(section);
                    });

                } else {
                    // object → each key as collapsible
                    Object.entries(obj).forEach(([key, val]) => {
                        const section = document.createElement('div');
                        section.style = 'margin-left:12px; border-left:1px solid #444; padding-left:6px;';
                        const title = document.createElement('div');
                        title.textContent = key;
                        title.style = 'font-weight:bold; cursor:pointer;';
                        section.appendChild(title);
                        const content = document.createElement('div');
                        content.style = 'display:none;';
                        renderObject(val, content);
                        section.appendChild(content);
                        title.onclick = () => {
                            content.style.display = content.style.display === 'none' ? 'block' : 'none';
                        };
                        parent.appendChild(section);
                    });
                }
            }

            for (const [ctxId, objs] of Object.entries(groups)) {
                // header
                const header = document.createElement('div');
                header.id = `header-${ctxId}`;
                header.className = 'sidebar-header';
                header.style =
                    'cursor:pointer; padding:2px 8px; border-left:1px dashed #555; border-bottom:1px solid #333; margin-top:8; display:flex; justify-content:space-between;';
                header.textContent = `${objs[0].domain} | ${objs[0].component} | ${objs[0].semantic_label}`;
                const idSpan = document.createElement('span');
                idSpan.textContent = ctxId;
                idSpan.style = 'opacity:0.6; font-size:0.75rem;';
                header.appendChild(idSpan);
                container.appendChild(header);

                // collapsible dropdown container
                const dropdown = document.createElement('div');
                dropdown.id = `dropdown-${ctxId}`;
                dropdown.style = 'display:none; margin-left:4px;';
                objs.forEach((o, idx) => {
                    const itemContainer = document.createElement('div');
                    itemContainer.id = `sidebar-item-container-${ctxId}-${idx}`;
                    itemContainer.style =
                        'padding:4px 0; cursor:pointer; border-bottom:1px solid #333;';
                    renderObject(o, itemContainer);
                    itemContainer.onclick = () => tweenToNode(ctxId);
                    dropdown.appendChild(itemContainer);
                });
                container.appendChild(dropdown);

                // toggle expand/collapse group
                header.onclick = () => {
                    const isHidden = dropdown.style.display === 'none';
                    dropdown.style.display = isHidden ? 'block' : 'none';
                };
            }
        }


        let isBuilding = false;
        //////////////////////////////////////////////////////////////////////////
        // BATCHED NODE CREATION
        //////////////////////////////////////////////////////////////////////////

        // break up large inserts into ~500-item chunks so the browser stays responsive
        async function batchAddNodes(objects) {
            isBuilding = true;
            const chunkSize = 500;
            for (let i = 0; i < objects.length; i += chunkSize) {
                const batch = objects.slice(i, i + chunkSize);
                addNodes(batch);
                rebuildEdges();
                // let the browser breathe
                await new Promise(r => requestAnimationFrame(r));
            }
            isBuilding = false;
        }

        // start both counts at zero
        instMesh && (instMesh.count = 0);
        instEdge && (instEdge.count = 0);
        /** called with *only* brand-new parsed objects */
        // ─── UPDATED appendNodesFast ──────────────────────────────────────────
        function appendNodesFast(newObjs, flashWhite = false) {
            // 0️⃣ Filter out duplicates
            const fresh = newObjs.filter(o => !nodeMap.has(o.context_id));
            if (!fresh.length) return;

            // 1️⃣ Ensure mesh exists & has room
            ensureSphereMesh();
            while (freeNodeIx + fresh.length > instMesh.countCapacity) {
                growInstancedMesh(instMesh);
            }

            // 2️⃣ Update palette & connectivity ceiling
            const comps = new Set([...nodeMap.values()].map(n => n.data.component));
            fresh.forEach(o => comps.add(o.component));
            hueMapCurrent = Object.fromEntries(
                [...comps].map((c, i) => [c, i / comps.size])
            );
            maxConnCurrent = Math.max(
                maxConnCurrent,
                ...fresh.map(o =>
                    (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length
                )
            );

            // 3️⃣ Append each newcomer with a Y‐tween
            const clr = new THREE.Color();
            const now = Date.now();
            const groupY = graphGroup.position.y;

            for (const o of fresh) {
                const idx = freeNodeIx++;

                // compute connectivity
                const conn = (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length;

                // final (target) local Y
                const ageMs = now - parseTimestamp(o.timestamp).getTime();
                const globalY = Math.max(
                    LAYOUT_CONFIG.minSphereY,
                    ageMs / LAYOUT_CONFIG.msPerUnit
                );
                const localY = globalY - groupY;

                // scatter XZ
                const rNorm = 1 - (conn / maxConnCurrent);
                const r = rNorm * LAYOUT_CONFIG.maxXZRadius;
                const ang = Math.random() * Math.PI * 2;
                const x = Math.cos(ang) * r, z = Math.sin(ang) * r;

                // record entry with tween metadata
                nodeMap.set(o.context_id, {
                    data: o,
                    // final position
                    pos: new THREE.Vector3(x, localY, z),
                    // initial injection at world Y=0 → localY = –groupY
                    prevPos: new THREE.Vector3(x, -groupY, z),
                    tweenStart: performance.now(),
                    tweenDuration: 800,
                    connectivity: conn,
                    mesh: instMesh,
                    _instanceIndex: idx
                });

                // set initial matrix at prevPos
                instMesh.setMatrixAt(
                    idx,
                    new THREE.Matrix4().makeTranslation(x, -groupY, z)
                );

                // color
                const hue = hueMapCurrent[o.component] ?? 0;
                const sat = 0.5 + 0.5 * (conn / maxConnCurrent);
                if (flashWhite) {
                    instMesh.instanceColor.setXYZ(idx, 1, 1, 1);
                    setTimeout(() => {
                        instMesh.instanceColor.setXYZ(
                            idx,
                            ...clr.setHSL(hue, sat, 0.5).toArray()
                        );
                        instMesh.instanceColor.needsUpdate = true;
                    }, 60);
                } else {
                    instMesh.instanceColor.setXYZ(
                        idx,
                        ...clr.setHSL(hue, sat, 0.5).toArray()
                    );
                }

                console.info('[spawn]', o.context_id, '→ instance', idx);
            }

            // 4️⃣ Commit GPU updates
            instMesh.count = freeNodeIx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            // 5️⃣ Rebuild JUST these edges & fire upstream flash
            rebuildEdgesIncremental(fresh.map(o => o.context_id));
            fresh.forEach(o => cascadeChain(o.context_id));
        }

        /** super-fast colour setter used by both add + later filter tweaks */
        function colourNode(idx, obj) {
            const hue = hueMapCurrent[obj.component] ?? 0;
            const sat = 0.6;
            const lgt = 0.8;
            instMesh.instanceColor.setXYZ(idx,
                ...new THREE.Color().setHSL(hue, sat, lgt).toArray());
        }
        function appendEdgesFast(srcObjs) {
            ensureEdgeMesh();

            const mat = new THREE.Matrix4();
            const yAxis = new THREE.Vector3(0, 1, 0);

            for (const o of srcObjs) {
                const entry = nodeMap.get(o.context_id);
                if (!entry) continue;

                const srcPos = entry.pos.clone();
                const cIdx = entry._instanceIndex;
                const refs = Array.isArray(o.references) ? o.references : [];
                const assocs = o.association_strengths
                    ? Object.keys(o.association_strengths)
                    : [];
                const targets = [...refs, ...assocs];

                for (const tgtId of targets) {
                    const tgtEntry = nodeMap.get(tgtId);
                    if (!tgtEntry) continue;

                    const tgtPos = tgtEntry.pos.clone();
                    const dir = new THREE.Vector3().subVectors(tgtPos, srcPos);
                    const len = dir.length();
                    if (len === 0) continue;

                    // if we're about to overflow, grow capacity now
                    if (freeEdgeIx + 1 > instEdge.countCapacity) {
                        growMeshCapacity(instEdge);
                    }

                    // build the edge transform
                    const q = new THREE.Quaternion().setFromUnitVectors(yAxis, dir.normalize());
                    const s = new THREE.Vector3(0.2, len, 0.2);
                    mat.compose(srcPos, q, s);
                    instEdge.setMatrixAt(freeEdgeIx, mat);

                    // copy the source node's color
                    const r = instMesh.instanceColor.getX(cIdx);
                    const g = instMesh.instanceColor.getY(cIdx);
                    const b = instMesh.instanceColor.getZ(cIdx);
                    instEdge.instanceColor.setXYZ(freeEdgeIx, r, g, b);

                    // record edge metadata
                    edges[freeEdgeIx] = {
                        source: o.context_id,
                        target: tgtId,
                        index: freeEdgeIx,
                        weight: (o.association_strengths?.[tgtId] || 1)
                    };

                    freeEdgeIx++;
                }

                // **after** wiring up all the new edges for this node,
                // light up its entire upstream‐chain:
                highlightPathFrom(o.context_id);
            }

            // commit to GPU
            instEdge.count = freeEdgeIx;
            instEdge.instanceMatrix.needsUpdate = true;
            instEdge.instanceColor.needsUpdate = true;
        }




        function pickPosition(o) {
            const conn = (o.references?.length || 0)
                + Object.keys(o.association_strengths || {}).length;
            maxConnCurrent = Math.max(maxConnCurrent, conn);

            // compute age in ms
            const now = Date.now();
            const ageMs = now - parseTimestamp(o.timestamp).getTime();

            // map to world-space Y
            const globalY = (ageMs * LAYOUT_CONFIG.spawnFactor) / LAYOUT_CONFIG.msPerUnit;
            const desiredY = Math.max(LAYOUT_CONFIG.minSphereY, globalY);

            // convert to local by subtracting current drift
            const localY = desiredY - graphGroup.position.y;

            // scatter around XZ
            const rNorm = 1 - (conn / maxConnCurrent);
            const r = rNorm * LAYOUT_CONFIG.maxXZRadius;
            const ang = Math.random() * Math.PI * 2;

            const pos = new THREE.Vector3(
                Math.cos(ang) * r,
                localY,
                Math.sin(ang) * r
            );

            o.pos = pos;
            o.connectivity = conn;
            return pos;
        }

        function ensureSphereMesh() {
            if (instMesh) return;

            const geo = new THREE.SphereGeometry(5, 4, 4);
            instMesh = new THREE.InstancedMesh(
                geo,
                new THREE.MeshLambertMaterial({ vertexColors: true }),
                START_CAP);

            instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const cAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(START_CAP * 3), 3);
            instMesh.geometry.setAttribute('color', cAttr);
            instMesh.instanceColor = cAttr;
            instMesh.countCapacity = START_CAP;
            instMesh.count = 0;

            graphGroup.add(instMesh);
        }

        function ensureEdgeMesh() {
            if (instEdge) return;
            const geo = new THREE.BoxGeometry(0.1, 1, 0.1);
            geo.translate(0, 0.5, 0);

            instEdge = new THREE.InstancedMesh(
                geo,
                new THREE.MeshBasicMaterial({ vertexColors: true }),
                START_CAP * 4
            );
            instEdge.frustumCulled = false;

            // ✏️ allocate the full capacity, and name it `instanceColor`
            const cAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(instEdge.countCapacity * 3), 3
            );
            instEdge.geometry.setAttribute('instanceColor', cAttr);
            instEdge.instanceColor = cAttr;

            graphGroup.add(instEdge);
        }

        /***********************************************************************
         *  growInstancedMesh(oldMesh)
         *  doubles capacity (up to 65535 instances – WebGL1 limit)
         **********************************************************************/
        function growInstancedMesh(old) {
            const newCap = Math.min(old.countCapacity * 2, 0xFFFF);
            const geo = old.geometry.clone();
            const mat = old.material.clone();
            const neo = new THREE.InstancedMesh(geo, mat, newCap);

            /* copy transforms */
            for (let i = 0; i < old.count; i++) {
                old.getMatrixAt(i, neo.matrix);
                neo.setMatrixAt(i, neo.matrix);
            }

            /* copy colours */
            const newColAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(newCap * 3), 3
            );
            neo.geometry.setAttribute('color', newColAttr);
            neo.instanceColor = newColAttr;
            for (let i = 0; i < old.count; i++) {
                newColAttr.setXYZ(
                    i,
                    old.instanceColor.getX(i),
                    old.instanceColor.getY(i),
                    old.instanceColor.getZ(i)
                );
            }

            neo.count = old.count;
            neo.countCapacity = newCap;
            neo.frustumCulled = false;
            neo.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            neo.geometry.boundingSphere = old.geometry.boundingSphere;

            /* replace in the scene */
            graphGroup.remove(old);
            graphGroup.add(neo);
            instMesh = neo;   // global swap
            console.warn('[grow] InstancedMesh capacity →', newCap);
            return neo;
        }
        /* ─────────────────────────────  add / update spheres  ───────────────────────────── */
        function addNodes(objs, flashWhite = false) {

            /* ───────────────────────────────────
             * 0️⃣  Filter out duplicates up-front
             * ─────────────────────────────────── */
            const fresh = objs.filter(o => !nodeMap.has(o.context_id));
            if (!fresh.length) return;

            /* ───────────────────────────────────
             * 1️⃣  Build InstancedMesh (lazy)
             * ─────────────────────────────────── */
            if (!instMesh) {
                const geo = new THREE.SphereGeometry(
                    DISPLAY_CONFIG.sphereRadius,
                    DISPLAY_CONFIG.sphereSegments,
                    DISPLAY_CONFIG.sphereSegments
                );
                instMesh = new THREE.InstancedMesh(
                    geo,
                    new THREE.MeshLambertMaterial({ vertexColors: true }),
                    HARD_MAX_NODES             // ← hard upper bound, never realloc
                );
                instMesh.frustumCulled = false;
                instMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

                const colAttr = new THREE.InstancedBufferAttribute(
                    new Float32Array(HARD_MAX_NODES * 3), 3
                );
                instMesh.geometry.setAttribute('color', colAttr);
                instMesh.instanceColor = colAttr;
                instMesh.geometry.boundingSphere =
                    new THREE.Sphere(new THREE.Vector3(), 1e6);

                graphGroup.add(instMesh);
            }

            /* ───────────────────────────────────
             * 2️⃣  Prune if we’ll overflow
             * ─────────────────────────────────── */
            const overflow = (instMesh.count + fresh.length) - HARD_MAX_NODES;
            if (overflow > 0) pruneOldest(overflow);   // remove N oldest nodes

            /* ───────────────────────────────────
             * 3️⃣  Re-compute palette helpers
             * ─────────────────────────────────── */
            const comps = new Set([...nodeMap.values()].map(n => n.data.component));
            fresh.forEach(o => comps.add(o.component));
            hueMapCurrent = Object.fromEntries(
                [...comps].map((c, i) => [c, i / comps.size])
            );

            /* update connectivity ceiling */
            maxConnCurrent = Math.max(
                maxConnCurrent,
                ...fresh.map(o =>
                    (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length)
            );

            /* colour helper */
            const clr = new THREE.Color();
            const now = Date.now();
            let idx = instMesh.count;     // first free slot

            /* ───────────────────────────────────
             * 4️⃣  Append each newcomer
             * ─────────────────────────────────── */
            for (const o of fresh) {
                /* position */
                const conn = (o.references?.length || 0) +
                    Object.keys(o.association_strengths || {}).length;
                const age = now - parseTimestamp(o.timestamp).getTime();
                const yPos = Math.max(LAYOUT_CONFIG.minSphereY,
                    age / LAYOUT_CONFIG.msPerUnit);
                const r = (1 - conn) * LAYOUT_CONFIG.maxXZRadius;
                const ang = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(Math.cos(ang) * r, yPos, Math.sin(ang) * r);

                instMesh.setMatrixAt(idx, new THREE.Matrix4().setPosition(pos));

                /* palette colour */
                const hue = hueMapCurrent[o.component] ?? 0;
                const sat = 0.5 + 0.5 * (conn / maxConnCurrent);
                instMesh.instanceColor.setXYZ(
                    idx, ...clr.setHSL(hue, sat, 0.5).toArray()
                );
                if (flashWhite) instMesh.instanceColor.setXYZ(idx, 1, 1, 1);

                /* bookkeeping */
                nodeMap.set(o.context_id, {
                    data: o, pos, connectivity: conn,
                    mesh: instMesh, _instanceIndex: idx
                });

                console.info('[spawn]', o.context_id, '→ instance', idx);
                idx++;
            }

            /* commit GPU updates */
            instMesh.count = idx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            rebuildEdgesIncremental(fresh.map(o => o.context_id)); // add edges from newcomers
        }

        /*********************************************************************
         *  pruneOldest(n)
         *  — removes the n oldest nodes (smallest timestamp) from scene & state
         *********************************************************************/
        function pruneOldest(n) {
            if (n <= 0) return;

            /* pick candidates: sort by original timestamp ASC */
            const victims = [...nodeMap.values()]
                .sort((a, b) =>
                    parseTimestamp(a.data.timestamp) - parseTimestamp(b.data.timestamp))
                .slice(0, n);

            for (const victim of victims) {
                const rmIdx = victim._instanceIndex;

                /* 1) remove from nodeMap */
                nodeMap.delete(victim.data.context_id);

                /* 2) compact InstancedMesh by moving last instance into the hole */
                const lastIdx = instMesh.count - 1;
                if (rmIdx !== lastIdx) {
                    // copy matrix & colour
                    instMesh.getMatrixAt(lastIdx, _tmpMat4);
                    instMesh.setMatrixAt(rmIdx, _tmpMat4);

                    instMesh.instanceColor.setXYZ(
                        rmIdx,
                        instMesh.instanceColor.getX(lastIdx),
                        instMesh.instanceColor.getY(lastIdx),
                        instMesh.instanceColor.getZ(lastIdx)
                    );

                    // update bookkeeping of the node that was moved
                    const movedNode = [...nodeMap.values()]
                        .find(n => n._instanceIndex === lastIdx);
                    if (movedNode) movedNode._instanceIndex = rmIdx;
                }
                instMesh.count--;  // shrink by one
            }

            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            /* remove any edges that referenced dead nodes and rebuild */
            edges = edges.filter(e =>
                nodeMap.has(e.source) && nodeMap.has(e.target)
            );
            rebuildEdges();   // full rebuild is simple & fast enough at this size
        }

        /* temp scratch matrix for pruneOldest() */
        const _tmpMat4 = new THREE.Matrix4();


        function rebuildEdgesIncremental(srcIds) {
            /* make sure the InstancedMesh and colour buffer exist */
            initEdges();
            const colAttr = instEdge.instanceColor;

            let ei = instEdge.count || 0;              // append after existing edges
            const tmpMat = new THREE.Matrix4();
            const axisY = new THREE.Vector3(0, 1, 0);

            srcIds.forEach(srcId => {
                const n = nodeMap.get(srcId);
                if (!n) return;

                /* strongest weight per target */
                const links = new Map();
                (n.data.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(n.data.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w)));

                links.forEach((w, tgtId) => {
                    const tgt = nodeMap.get(tgtId);
                    if (!tgt || ei >= MAX_EDGES) return;

                    /* direction & length */
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const len = dir.length();
                    if (!len) return;                       // avoid zero-length edges

                    const quat = new THREE.Quaternion().setFromUnitVectors(axisY, dir.normalize());

                    /* variable thickness */
                    const t = edgeThickness(w);

                    /* compose transform and write instance matrix */
                    tmpMat.compose(n.pos, quat, new THREE.Vector3(t, len, t));
                    instEdge.setMatrixAt(ei, tmpMat);

                    /* colour = RGB of the source node */
                    const srcIdx = n._instanceIndex;
                    colAttr.setXYZ(
                        ei,
                        instMesh.instanceColor.getX(srcIdx),
                        instMesh.instanceColor.getY(srcIdx),
                        instMesh.instanceColor.getZ(srcIdx)
                    );

                    /* edge metadata */
                    edges[ei] = { source: srcId, target: tgtId, index: ei, weight: w };

                    ei++;
                });
            });

            /* commit to GPU */
            instEdge.frustumCulled = false;       // ← ADD THIS HERE, too
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }



        /* ─── append ONLY the brand-new edges coming from newObjs ────────────── */
        function addEdges(newObjs) {
            initEdges();                              // InstancedMesh already set up

            const colAttr = instEdge.instanceColor;   // colour buffer (no alpha logic)
            let idx = instEdge.count;           // first free instance slot

            for (const obj of newObjs) {
                const srcNode = nodeMap.get(obj.context_id);
                if (!srcNode) continue;

                /* pick the strongest link weight per target */
                const links = new Map();
                (obj.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(obj.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w)));

                for (const [tgtId, w] of links) {
                    const tgtNode = nodeMap.get(tgtId);
                    if (!tgtNode || idx >= MAX_EDGES) continue;

                    /* build transform (stretch unit box to full edge length) */
                    const dir = new THREE.Vector3().subVectors(tgtNode.pos, srcNode.pos);
                    const len = dir.length();
                    if (!len) continue;

                    const quat = new THREE.Quaternion()
                        .setFromUnitVectors(new THREE.Vector3(0, 1, 0),
                            dir.normalize());

                    instEdge.setMatrixAt(
                        idx,
                        new THREE.Matrix4().compose(
                            srcNode.pos,
                            quat,
                            new THREE.Vector3(edgeThickness(w), len, edgeThickness(w))
                        )
                    );

                    /* starting colour = mid-grey */
                    colAttr.setXYZ(idx, BASE_EDGE_GREY, BASE_EDGE_GREY, BASE_EDGE_GREY);

                    /* metadata for hover / cascade logic */
                    edges[idx] = { source: obj.context_id, target: tgtId, index: idx, weight: w };

                    idx++;
                }
            }

            /* commit to GPU */
            instEdge.count = idx;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }



        // recompute max connectivity once per batch
        function computeMaxConnectivity() {
            return Math.max(
                1,
                ...[...nodeMap.values()].map(n => n.connectivity)
            );
        }
        /* ─── INITIAL FULL LOAD  (runs once) ────────────────────────────────── */
        async function loadGraph() {
            const url = getContextFileUrl(false);
            console.log('[loadGraph] initial load from', url);

            clearScene();                 // wipe scene & JS-side state
            remoteSize = 0;               // reset processed-byte counter

            /* 1️⃣  grab the whole file (no cache-buster, so HEAD/RANGE work later) */
            const fullRes = await fetch(url, { cache: 'no-store' });
            const fullText = await fullRes.text();

            /* 2️⃣  record EXACT byte length reported by the server */
            const lenHdr = fullRes.headers.get('Content-Length');
            remoteSize = lenHdr ? Number(lenHdr)                    // preferred
                : new TextEncoder().encode(fullText).length;

            /* 3️⃣  parse every JSON-line */
            const objs = fullText
                .trim()                 // safe to trim for parsing
                .split(/\r?\n/)
                .filter(Boolean)
                .map(JSON.parse);

            objs.forEach(o => seenIds.add(o.context_id));
            await batchAddNodes(objs);   // spheres
            addEdges(objs);              // edges

            allData = [...nodeMap.values()].map(n => n.data);

            // initial population
            populateDomainFilter(allData);
            populateComponentFilter(allData, '');
            populateSemanticFilter(allData, '', '');

            applyFilters();
            prevLineCount = objs.length;
            initialLoadDone = true;

            // set free-indices so fast appends pick up where full load left off
            freeNodeIx = instMesh.count;
            freeEdgeIx = instEdge?.count || 0;
        }

        // Find your existing loadGraph override at the bottom of your module:
        const oldLoadGraph = loadGraph;
        loadGraph = async function (...args) {
            await oldLoadGraph(...args);

            // 1) re‐layout nodes via D3
            runForceLayout();

            // 2) rebuild ALL edges to match new node positions
            updateEdgeMeshes();

            // 3) rebuild sidebar
            buildSidebarList(allData);
        };



        async function grabTailChunk(url,
            maxBytes = 128 * 1024,
            wantLines = 300) {

            /* try a single Range fetch first */
            try {
                const res = await fetch(url, {
                    headers: { Range: `bytes=-${maxBytes}` },
                    cache: 'no-store'
                });
                if (res.status === 206) {                     // honoured → trivial
                    const txt = await res.text();
                    return txt.trim().split(/\r?\n/).slice(-wantLines);
                }
                /* else fall through – some servers just return 200 */
            } catch { /* ignore → streaming fallback */ }

            /* streaming fallback (no Range support, no C-L checks → no mismatch) */
            const bust = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();
            const res = await fetch(bust, { cache: 'no-store' });
            const rdr = res.body?.getReader?.();

            if (!rdr) {                             // no streams? read whole file
                const txt = await res.text();
                return txt.trim().split(/\r?\n/).slice(-wantLines);
            }

            const dec = new TextDecoder();
            let buf = '';
            const lines = [];

            while (true) {
                const { value, done } = await rdr.read();
                if (done) break;

                buf += dec.decode(value, { stream: true });
                const parts = buf.split(/\r?\n/);
                buf = parts.pop();
                lines.push(...parts);

                if (lines.length >= wantLines + 50) {   // small margin, then stop
                    rdr.cancel().catch(() => { });
                    break;
                }
            }
            buf += dec.decode();
            if (buf) lines.push(buf);

            return lines.filter(Boolean).slice(-wantLines);
        }


        async function grabTailLines(url, wantLines = 50, offset = 0) {

            // always bust cache so browsers never reuse a half-served response
            const bust = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();

            try {
                const res = await fetch(bust, {
                    headers: { Range: `bytes=${offset}-` },   // hope for 206
                    cache: 'no-store'
                });

                /* ===== CASE 1 – server honours Range (206) ======================= */
                if (res.status === 206) {
                    const txt = await res.text();
                    const lines = txt.trim().split(/\r?\n/).filter(Boolean).slice(-wantLines);
                    const newOffset = offset + new TextEncoder().encode(txt).length;
                    return { lines, newOffset };
                }

                /* ===== CASE 2 – server ignores Range (200) – stream & abort ====== */
                const reader = res.body?.getReader?.();

                // No stream available (older server) – read the whole thing
                if (!reader) {
                    const txt = await res.text();
                    const all = txt.trim().split(/\r?\n/).filter(Boolean);
                    const size = new TextEncoder().encode(txt).length;
                    return { lines: all.slice(-wantLines), newOffset: size };
                }

                const dec = new TextDecoder();
                let buffer = '';
                const lines = [];
                let bytes = 0;               // track how many bytes we really read

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    bytes += value.byteLength;
                    buffer += dec.decode(value, { stream: true });
                    const parts = buffer.split(/\r?\n/);
                    buffer = parts.pop();
                    lines.push(...parts);

                    if (lines.length >= wantLines + 5) {      // small margin
                        reader.cancel().catch(() => { });
                        break;
                    }
                }
                buffer += dec.decode();
                if (buffer) { lines.push(buffer); bytes += buffer.length; }

                return {
                    lines: lines.filter(Boolean).slice(-wantLines),
                    newOffset: offset + bytes          // advance by what we actually read
                };

            } catch (err) {
                console.warn('[grabTailLines] request failed:', err);
                return { lines: [], newOffset: offset };       // graceful degradation
            }
        }
        function cascadeUpstream(originId) {
            if (!edges.length || !instEdge) return;

            const visited = new Set([originId]);
            const queue = [{ id: originId, depth: 0 }];
            const MAX_D = DISPLAY_CONFIG.maxChainDepth ?? 10;         // fallback ≡ 3
            const DELAY = DISPLAY_CONFIG.chainDelay * 200;        // ms per hop

            while (queue.length) {
                const { id, depth } = queue.shift();
                if (depth >= MAX_D) continue;

                const n = nodeMap.get(id);
                if (!n) continue;

                /* gather all upstream neighbours (references + assoc_strengths keys) */
                const nbrIds = new Set([
                    ...(n.data.references || []),
                    ...Object.keys(n.data.association_strengths || {})
                ]);

                for (const nbrId of nbrIds) {
                    if (!nodeMap.has(nbrId) || visited.has(nbrId)) continue;

                    /* find the edge object that connects id ↔︎ nbrId */
                    const e = edges.find(ed =>
                        (ed.source === id && ed.target === nbrId) ||
                        (ed.source === nbrId && ed.target === id)
                    );
                    if (!e) continue;           // edge might not exist (filtered out)

                    /* schedule a pulse for this edge only */
                    const baseAlpha = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);
                    setTimeout(() => pulseEdge(e.index, baseAlpha), DELAY * depth);

                    /* enqueue neighbour for the next shell */
                    queue.push({ id: nbrId, depth: depth + 1 });
                    visited.add(nbrId);
                }
            }
        }

       async function pollForNew() {
  const url = getContextFileUrl(true);
  console.groupCollapsed(`[poll] ${new Date().toISOString()}`);

  // ① HEAD → check length / etag
  let head;
  try {
    head = await fetch(url, { method: "HEAD", cache: "no-store" });
  } catch (e) {
    console.warn("HEAD failed", e);
    console.groupEnd();
    return;
  }
  const size = Number(head.headers.get("Content-Length") || 0);
  const etag = head.headers.get("ETag") || "";

  // no change?
  if (size === lastSize && etag === lastETag) {
    console.debug("no change – skipping GET");
    console.groupEnd();
    return;
  }
  // file was rotated (shrunk)?
  if (size < lastSize) lastContextId = null;

  // ② GET the tail
  const rangeStart = Math.max(0, size - LAST_KB * 1024);
  let res;
  try {
    res = await fetch(url, {
      headers: { Range: `bytes=${rangeStart}-` },
      cache: "no-store"
    });
  } catch (e) {
    console.warn("GET failed", e);
    console.groupEnd();
    return;
  }

  const rangeHonoured = res.status === 206;
  console.debug(`GET ${res.status} (Range honoured? ${rangeHonoured})`);

  let chunk = "";
  if (rangeHonoured) {
    chunk = await res.text();
  } else if (res.body && res.body.getReader) {
    // fallback streaming until enough lines
    const rdr = res.body.getReader();
    const dec = new TextDecoder();
    let buf = "", lines = [], seen = lastContextId === null;
    try {
      while (true) {
        const { value, done } = await rdr.read();
        if (done) break;
        buf += dec.decode(value, { stream: true });
        const parts = buf.split(/\r?\n/);
        buf = parts.pop();
        for (const ln of parts) {
          if (!ln) continue;
          if (!seen) {
            if (lastContextId === null || ln.includes(lastContextId)) {
              seen = true;
            }
            continue;
          }
          lines.push(ln);
          if (lines.length >= WANT_LINES) {
            await rdr.cancel();
            break;
          }
        }
        if (lines.length >= WANT_LINES) break;
      }
      if (buf && seen) lines.push(buf);
      chunk = lines.join("\n");
    } catch (err) {
      console.warn("stream error", err);
      try { await rdr.cancel(); } catch {}
    }
  } else {
    console.warn("Stream API not available → bailing");
    console.groupEnd();
    return;
  }

  // ③ parse & dedupe
  const fresh = [];
  chunk.split(/\r?\n/).forEach(ln => {
    if (!ln.trim()) return;
    try {
      const o = JSON.parse(ln);
      if (o.context_id && !seenIds.has(o.context_id)) {
        seenIds.add(o.context_id);
        fresh.push(o);
      }
    } catch {}
  });

  console.debug("fresh objects:", fresh.length);
  if (fresh.length) {
    // update 3D graph
    appendNodesFast(fresh, true);
    appendEdgesFast(fresh);

    // bump sentinel
    lastContextId = fresh[fresh.length - 1].context_id;

    // merge & rebuild sidebar
    allData.push(...fresh);
    buildSidebarList(allData);

    // auto-scroll if allowed
    if (autoScrollEnabled) {
      sidebar.scrollTop = sidebar.scrollHeight;
    }

    // re-apply filters so new nodes get correct coloring
    applyFilters();
  }

  // ④ remember state
  lastSize = size;
  lastETag = etag;
  console.groupEnd();
}


        // ─── BUILD SCENE ──────────────────────────────────────────────────
        function buildScene(objects) {
            // sort by timestamp (newest first)
            objects.sort((a, b) =>
                parseTimestamp(b.timestamp) - parseTimestamp(a.timestamp)
            );

            const now = Date.now();
            nodeMap.clear();

            // index + compute connectivity
            objects.forEach(o => {
                const conn = (o.references?.length || 0)
                    + Object.keys(o.association_strengths || {}).length;
                nodeMap.set(o.context_id, {
                    data: o,
                    mesh: null,
                    pos: new THREE.Vector3(),
                    connectivity: conn
                });
            });

            // layout: Y = age, XZ scatter by connectivity
            const maxConn = Math.max(...[...nodeMap.values()].map(n => n.connectivity), 1);
            nodeMap.forEach(n => {
                const age = now - parseTimestamp(n.data.timestamp).getTime();
                n.pos.y = Math.max(LAYOUT_CONFIG.minSphereY, age / LAYOUT_CONFIG.msPerUnit);
                const norm = 1 - (n.connectivity / maxConn);
                const r = norm * LAYOUT_CONFIG.maxXZRadius;
                const a = Math.random() * Math.PI * 2;
                n.pos.x = Math.cos(a) * r;
                n.pos.z = Math.sin(a) * r;
            });


            // 1) At initialization (once):

            {
                const lineGeo = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 1, 0)
                ]);

                instEdge = new THREE.InstancedMesh(lineGeo, edgeMaterial, MAX_EDGES);
                instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instEdge.geometry.setAttribute(
                    'alpha',
                    new THREE.InstancedBufferAttribute(new Float32Array(MAX_EDGES), 1)
                        .setUsage(THREE.DynamicDrawUsage)
                );

                graphGroup.add(instEdge);
            }


            let ei = 0;
            nodeMap.forEach((n, id) => {
                // gather all connections
                const conns = new Map();
                (n.data.references || []).forEach(rid => conns.set(rid, 1));
                Object.entries(n.data.association_strengths || {}).forEach(([rid, w]) =>
                    conns.set(rid, Math.max(conns.get(rid) || 0, w))
                );

                conns.forEach((w, oid) => {
                    const tgt = nodeMap.get(oid);
                    if (!tgt) return;

                    // compute direction vector and length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, n.pos);
                    const length = dir.length();
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        dir.normalize()
                    );

                    // build the instance transform
                    const matrix = new THREE.Matrix4().compose(
                        n.pos,                         // translation
                        quat,                          // orientation
                        new THREE.Vector3(1, length, 1) // scale (stretch line to length)
                    );

                    instEdge.setMatrixAt(ei, matrix);
                    instEdge.geometry.attributes.alpha.setX(
                        ei,
                        DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, w)
                    );
                    ei++;
                });
            });

            // finalize instance count and upload updates
            instEdge.count = ei;
            instEdge.geometry.attributes.alpha.needsUpdate = true;

            // refresh UI filters if needed…
            populateTypeFilter(objects);
            applyFilters();
        }
        // ─── INITIALIZE ──────────────────────────────────────────────────
        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);
        domainSel.addEventListener('change', () => {
            populateComponentFilter(allData, domainSel.value);
            populateSemanticFilter(allData, domainSel.value, componentSel.value);
            applyFilters();
        });

        componentSel.addEventListener('change', () => {
            populateSemanticFilter(allData, domainSel.value, componentSel.value);
            applyFilters();
        });

        semanticSel.addEventListener('change', () => {
            applyFilters();
        });
        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        //////////////////////////////////////////////////////////////////////////
        // THREE.JS SETUP
        //////////////////////////////////////////////////////////////////////////
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // ─── CAMERA ──────────────────────────────────────────────────────────
        const camera = new THREE.PerspectiveCamera(
            85,
            window.innerWidth / window.innerHeight,
            0.1,
            2e6
        );
        camera.position.set(0, -100, 0);
        camera.lookAt(0, 0, 0);    // baseline = looking along +Y (180° polar)

        // ─── RENDERER ────────────────────────────────────────────────────────
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ─── CONTROLS ────────────────────────────────────────────────────────
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // lock out zoom & pan
        controls.enableZoom = false;
        controls.enablePan = false;

        // (optional) flip horizontal drag direction
        controls.rotateSpeed = -controls.rotateSpeed;

        // full pitch range so you can sweep “up” and “down” around the Y-axis baseline
        controls.minPolarAngle = 0;       // look all the way “through” to –Y
        controls.maxPolarAngle = Math.PI; // back down to +Y

        // full 360° yaw
        controls.minAzimuthAngle = -Infinity;
        controls.maxAzimuthAngle = Infinity;

        // one-time sync
        controls.update();




        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        function onWheel(e) {
            e.preventDefault();

            // compute a positive baseDelta when wheel-down
            const baseDelta = e.deltaY * SCROLL_ACCEL;
            const dir = Math.sign(baseDelta);
            const now = Date.now();

            // build up boost if you’re flicking same direction quickly
            if (dir === lastWheelDir && (now - lastWheelTime) < 200) {
                scrollBoost = Math.min(BOOST_MAX, scrollBoost + BOOST_INCREMENT);
            } else {
                scrollBoost = 1;
            }
            lastWheelDir = dir;
            lastWheelTime = now;

            // non-linear flick + boost
            scrollVelocity += dir * Math.abs(baseDelta) ** 1.2 * scrollBoost;
        }




        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        scene.add(new THREE.AmbientLight(0xffffff, 5));
        const keyLight = new THREE.DirectionalLight(0xffffff, 5);
        keyLight.position.set(0, 0, 0);
        scene.add(keyLight);

        const graphGroup = new THREE.Group();
        scene.add(graphGroup);

        //////////////////////////////////////////////////////////////////////////
        // EDGE INSTANCED MESH SETUP (skinny box)
        //////////////////////////////////////////////////////////////////////////
        const MAX_EDGES = 20_000;
        /* ─── EDGE INSTANCED-MESH  (creates per-instance alpha attr + custom shader) ── */
        /* ─── EDGE INSTANCED-MESH  (base brightness = 0.1) ───────────────────── */
        /* 1️⃣  create (once) the InstancedMesh + per-edge alpha */
        // ───────────────────────────────────────────────────────────────────
        // ONE-TIME instanced-line mesh with per-instance colours
        // ───────────────────────────────────────────────────────────────────
        // ─── one-time InstancedMesh for all edges ──────────────────────────────
        function initEdges() {
            if (instEdge) return;

            // 1) build a thin box (pivot at bottom) for each edge
            const geo = new THREE.BoxGeometry(0.1, 1, 0.1);
            geo.translate(0, 0.5, 0); // move origin to base

            // 2) per-edge material
            const mat = new THREE.MeshBasicMaterial({
                vertexColors: true,    // ← look for a "color" attribute
                transparent: true,     // ← allow fade/alpha later
                depthWrite: false
            });

            // 3) create the InstancedMesh
            instEdge = new THREE.InstancedMesh(geo, mat, MAX_EDGES);
            instEdge.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            // 4) allocate & seed a "color" attribute (r,g,b per instance)
            const base = BASE_EDGE_GREY;
            const cols = new Float32Array(MAX_EDGES * 3).fill(base);
            const cAttr = new THREE.InstancedBufferAttribute(cols, 3)
                .setUsage(THREE.DynamicDrawUsage);

            // 5) attach it *as* the "color" attribute so the material picks it up
            instEdge.geometry.setAttribute('color', cAttr);
            // still convenient to reference it as `instEdge.instanceColor` in your code
            instEdge.instanceColor = cAttr;

            graphGroup.add(instEdge);
        }

        // ─── Ensure your per‐edge alpha attribute exists ──────────
        function ensureEdgeAlphaAttr() {
            if (!instEdge) return;                              // mesh not ready
            if (instEdge.geometry.attributes.alpha) return;     // already installed

            const alphaArr = new Float32Array(MAX_EDGES)
                .fill(DISPLAY_CONFIG.lineBaseOpacity);
            const aAttr = new THREE.InstancedBufferAttribute(alphaArr, 1)
                .setUsage(THREE.DynamicDrawUsage);

            instEdge.geometry.setAttribute('alpha', aAttr);
        }

        // ─── Full rebuild of every edge ─────────────────────────
        function rebuildEdges() {
            initEdges();               // make sure instEdge exists
            ensureEdgeAlphaAttr();     // install alpha buffer if needed

            const colAttr = instEdge.instanceColor;
            edges.length = 0;
            let ei = 0;

            nodeMap.forEach((src, srcId) => {
                // gather strongest‐weight per target
                const links = new Map();
                (src.data.references || []).forEach(rid => links.set(rid, 1));
                Object.entries(src.data.association_strengths || {})
                    .forEach(([rid, w]) =>
                        links.set(rid, Math.max(links.get(rid) || 0, w))
                    );

                links.forEach((w, tgtId) => {
                    const tgt = nodeMap.get(tgtId);
                    if (!tgt || ei >= MAX_EDGES) return;

                    // direction & length
                    const dir = new THREE.Vector3().subVectors(tgt.pos, src.pos);
                    const len = dir.length();
                    if (!len) return;

                    // orientation quaternion
                    const quat = new THREE.Quaternion()
                        .setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());

                    // thickness based on weight
                    const t = edgeThickness(w);

                    // write transform
                    instEdge.setMatrixAt(
                        ei,
                        new THREE.Matrix4().compose(
                            src.pos,
                            quat,
                            new THREE.Vector3(t, len, t)
                        )
                    );

                    // copy colour from source node
                    const srcIdx = src._instanceIndex;
                    const r = instMesh.instanceColor.getX(srcIdx);
                    const g = instMesh.instanceColor.getY(srcIdx);
                    const b = instMesh.instanceColor.getZ(srcIdx);
                    colAttr.setXYZ(ei, r, g, b);

                    edges.push({ source: srcId, target: tgtId, index: ei, weight: w });
                    ei++;
                });
            });

            // upload
            instEdge.count = ei;
            instEdge.instanceMatrix.needsUpdate = true;
            colAttr.needsUpdate = true;
        }


        //////////////////////////////////////////////////////////////////////////
        // USAGE—call these once at startup, then whenever nodeMap changes:
        //////////////////////////////////////////////////////////////////////////
        initEdges();
        if (!instEdge.geometry.attributes.alpha) {
            const base = DISPLAY_CONFIG.lineBaseOpacity;
            const aAttr = new THREE.InstancedBufferAttribute(
                new Float32Array(MAX_EDGES).fill(base), 1
            );
            instEdge.geometry.setAttribute('alpha', aAttr);
        }



        //////////////////////////////////////////////////////////////////////
        // HELPERS
        //////////////////////////////////////////////////////////////////////
        function parseTimestamp(ts) {
            const y = +ts.slice(0, 4), m = +ts.slice(4, 6) - 1, d = +ts.slice(6, 8),
                hh = +ts.slice(9, 11), mm = +ts.slice(11, 13), ss = +ts.slice(13, 15);
            return new Date(Date.UTC(y, m, d, hh, mm, ss));
        }
        function unixNow() { return Date.now(); }
        function edgeThickness(w) {
            const MIN = 0.1;   // thinnest possible edge
            const MAX = 10;   // thickest possible edge
            /* clamp & normalise:   0 → MIN,   1 or above → MAX  */
            w = Math.min(Math.max(w, 0), 1);
            return MIN + (MAX - MIN) * w;
        }
        function clearScene() {
            // ── remove all meshes (nodes & edges) under graphGroup
            graphGroup.children.slice().forEach(child => {
                graphGroup.remove(child);
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });

            // reset references to instanced meshes
            instMesh = null;
            instEdge = null;

            // reset group transform so next load starts at y = 0
            graphGroup.position.set(0, 0, 0);
            yScrollOffset = 0;
            lastDriftT = Date.now();

            // ── wipe JS-side state
            nodeMap.clear();
            edges.length = 0;
            pickableMeshes.length = 0;
            hovered = hoveredIdx = selectedId = null;
            prevCount = 0;

            // ── clear UI
            selPane.textContent = '// Hover or click a node…';
            detailPanel.innerHTML = '';
        }


        //////////////////////////////////////////////////////////////////////
        // FILTERS
        //////////////////////////////////////////////////////////////////////
        function populateDomainFilter(data) {
            const domains = [...new Set(data.map(o => o.domain))].sort();
            domainSel.innerHTML =
                '<option value="">All domains</option>' +
                domains.map(d => `<option value="${d}">${d}</option>`).join('');
        }

        function populateComponentFilter(data, domain) {
            const comps = [...new Set(
                data
                    .filter(o => !domain || o.domain === domain)
                    .map(o => o.component)
            )].sort();
            componentSel.innerHTML =
                '<option value="">All components</option>' +
                comps.map(c => `<option value="${c}">${c}</option>`).join('');
        }

        function populateSemanticFilter(data, domain, component) {
            const labels = [...new Set(
                data
                    .filter(o =>
                        (!domain || o.domain === domain) &&
                        (!component || o.component === component)
                    )
                    .map(o => o.semantic_label)     // adjust if your field is named differently
                    .filter(l => !!l)
            )].sort();
            semanticSel.innerHTML =
                '<option value="">All labels</option>' +
                labels.map(l => `<option value="${l}">${l}</option>`).join('');
        }

        function applyFilters() {
            const now = unixNow();
            const ageMax = ({
                h1: 3600e3, d1: 86400e3, w1: 86400e3 * 7,
                m1: 86400e3 * 30
            }[ageSel.value]) || 0;

            // new cascading filters
            const selDomain = domainSel.value;
            const selComponent = componentSel.value;
            const selSemantic = semanticSel.value;

            const color = new THREE.Color();

            /* 1️⃣  NODES */
            let writeIdx = 0;
            const liveIds = new Set();
            const selectedIds = new Set();

            nodeMap.forEach((n, ctxId) => {
                const o = n.data;

                // age filter
                if (ageMax) {
                    const age = now - parseTimestamp(o.timestamp).getTime();
                    if (age > ageMax) return;
                }
                liveIds.add(ctxId);

                // domain filter
                if (selDomain && o.domain !== selDomain) return;

                // component filter
                if (selComponent && o.component !== selComponent) return;

                // semantic_label filter
                if (selSemantic && o.semantic_label !== selSemantic) return;

                selectedIds.add(ctxId);

                // position
                instMesh.setMatrixAt(writeIdx,
                    new THREE.Matrix4().setPosition(n.pos));

                // colour
                if (ctxId === selectedId) {
                    // clicked – stay white
                    instMesh.instanceColor.setXYZ(writeIdx, 1, 1, 1);
                } else if (!selDomain && !selComponent && !selSemantic) {
                    // only age filter active
                    const hue = hueMapCurrent[o.component] || 0;
                    const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                    instMesh.instanceColor.setXYZ(
                        writeIdx, ...color.setHSL(hue, sat, 0.5).toArray());
                } else {
                    // cascading filters active
                    if (selectedIds.has(ctxId)) {
                        // passes all selected filters
                        instMesh.instanceColor.setXYZ(writeIdx, 1, 1, 1);
                    } else {
                        // filtered out → dim
                        const hue = hueMapCurrent[o.component] || 0;
                        const sat = 0.5 + 0.5 * (n.connectivity / maxConnCurrent);
                        instMesh.instanceColor.setXYZ(
                            writeIdx, ...color.setHSL(hue, sat, 0.25).toArray());
                    }
                }

                n._instanceIndex = writeIdx;
                writeIdx++;
            });

            instMesh.count = writeIdx;
            instMesh.instanceMatrix.needsUpdate = true;
            instMesh.instanceColor.needsUpdate = true;

            /* 2️⃣  EDGES */
            if (!instEdge) return;
            ensureEdgeAlphaAttr();
            const aAttr = instEdge.geometry.attributes.alpha;
            const cAttr = instEdge.instanceColor;

            edges.forEach(e => {
                const live = liveIds.has(e.source) && liveIds.has(e.target);
                aAttr.setX(e.index, live ? 1 : 0);
                if (!live) return;

                const srcNode = nodeMap.get(e.source);
                const srcIdx = srcNode._instanceIndex;
                cAttr.setXYZ(
                    e.index,
                    instMesh.instanceColor.getX(srcIdx),
                    instMesh.instanceColor.getY(srcIdx),
                    instMesh.instanceColor.getZ(srcIdx)
                );
            });
            aAttr.needsUpdate = true;
            cAttr.needsUpdate = true;

            /* 3️⃣  hover housekeeping */
            if (hovered && !liveIds.has(hovered)) {
                hovered = hoveredIdx = null;
                selPane.textContent = '// Hover or click a node…';
            }
        }




        //////////////////////////////////////////////////////////////////////
        // CAMERA DOLLY / TWEEN
        //////////////////////////////////////////////////////////////////////
        function tweenToNode(ctxId) {
            const n = nodeMap.get(ctxId);
            if (!n || !instMesh) return;

            /* 1️⃣  convert the node's *stored* local pos → world space *now* */
            const worldPos = n.pos.clone();          // local
            graphGroup.updateMatrixWorld();          // make sure world matrix is current
            graphGroup.localToWorld(worldPos);       // local → world

            /* 2️⃣  define camera path */
            const fromPos = camera.position.clone();
            const fromTarget = controls.target.clone();

            /* back the camera off slightly so the sphere isn't inside the near-plane */
            const toTarget = worldPos;
            const toPos = worldPos.clone().add(new THREE.Vector3(0, 100, 100)); // 10 up, 30 back

            /* 3️⃣  set up the tween */
            cameraTween = {
                fromPos, toPos,
                fromTarget, toTarget,
                start: performance.now(),
                duration: 600
            };
        }

        //////////////////////////////////////////////////////////////////////
        // DETAIL PANEL
        //////////////////////////////////////////////////////////////////////
        function populateDetail(id) {
            const obj = nodeMap.get(id).data;
            detailPanel.innerHTML = '';
            const tbl = document.createElement('table');

            Object.entries(obj).forEach(([k, v]) => {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                tdK.textContent = k;
                const tdV = document.createElement('td');

                // references array
                if (Array.isArray(v) && k === 'references') {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.textContent = rid;
                        a.className = 'ref-link';
                        a.onclick = e => {
                            e.preventDefault();
                            tweenToNode(rid);

                            // expand sidebar dropdown for this context_id
                            const dropdown = document.getElementById(`dropdown-${rid}`);
                            if (dropdown) dropdown.style.display = 'block';

                            // clear previous highlights
                            document.querySelectorAll('.sidebar-item-highlight')
                                .forEach(el => el.classList.remove('sidebar-item-highlight'));

                            // highlight & scroll to the first item container
                            const itemEl = document.getElementById(`sidebar-item-container-${rid}-0`);
                            if (itemEl) {
                                itemEl.classList.add('sidebar-item-highlight');
                                itemEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        };
                        tdV.appendChild(a);
                    });

                    // association_strengths object
                } else if (typeof v === 'object' && v !== null && k === 'association_strengths') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.textContent = `${rid} (${w})`;
                        a.className = 'ref-link';
                        a.onclick = e => {
                            e.preventDefault();
                            tweenToNode(rid);

                            // same sidebar logic as above
                            const dropdown = document.getElementById(`dropdown-${rid}`);
                            if (dropdown) dropdown.style.display = 'block';
                            document.querySelectorAll('.sidebar-item-highlight')
                                .forEach(el => el.classList.remove('sidebar-item-highlight'));
                            const itemEl = document.getElementById(`sidebar-item-container-${rid}-0`);
                            if (itemEl) {
                                itemEl.classList.add('sidebar-item-highlight');
                                itemEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = typeof v === 'object' ? JSON.stringify(v) : v;
                }

                tr.appendChild(tdK);
                tr.appendChild(tdV);
                tbl.appendChild(tr);
            });

            detailPanel.appendChild(tbl);
        }

        //////////////////////////////////////////////////////////////////////
        // CHAIN REACTION
        //////////////////////////////////////////////////////////////////////
        /**
         * Starting from `nodeId`, walk *all* references upstream
         * (breadth‐first) and pulse every connecting edge white.
         * Uses your existing pulseEdge(idx, baseGrey) which fades it back.
         */
        function highlightPathFrom(nodeId) {
            if (!instEdge || !edges.length) return;
            const seen = new Set([nodeId]);
            const queue = [nodeId];
            const axisY = new THREE.Vector3(0, 1, 0);

            while (queue.length) {
                const srcId = queue.shift();
                const srcNode = nodeMap.get(srcId);
                if (!srcNode) continue;

                // collect both references[] + association_strengths keys
                const ups = [
                    ...(srcNode.data.references || []),
                    ...Object.keys(srcNode.data.association_strengths || {})
                ];

                for (const tgtId of ups) {
                    if (!nodeMap.has(tgtId) || seen.has(tgtId)) continue;
                    seen.add(tgtId);
                    queue.push(tgtId);

                    // find the edge index that joins srcId -> tgtId
                    const e = edges.find(e =>
                        (e.source === srcId && e.target === tgtId) ||
                        (e.source === tgtId && e.target === srcId)
                    );
                    if (e) {
                        // pulse white, then fade back to its original grey
                        const baseGrey = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);
                        pulseEdge(e.index, baseGrey);
                    }
                }
            }
        }


        /***********************************************************************
     *  Bright-flash a single edge, then fade back to its original dim value
     **********************************************************************/
        // ─── 1) Improved pulseEdge that restores *both* color & alpha ─────────
        function pulseEdge(edgeIdx, peakAlpha = 1) {
            if (!instEdge) return;
            const cAttr = instEdge.instanceColor;
            const aAttr = instEdge.geometry.attributes.alpha;

            // stash original
            const r0 = cAttr.getX(edgeIdx),
                g0 = cAttr.getY(edgeIdx),
                b0 = cAttr.getZ(edgeIdx),
                a0 = aAttr.getX(edgeIdx);

            // flash to white & full alpha
            cAttr.setXYZ(edgeIdx, 1, 1, 1);
            aAttr.setX(edgeIdx, peakAlpha);
            cAttr.needsUpdate = true;
            aAttr.needsUpdate = true;

            // fade back after fadeOutDuration
            setTimeout(() => {
                if (!instEdge) return;
                cAttr.setXYZ(edgeIdx, r0, g0, b0);
                aAttr.setX(edgeIdx, a0);
                cAttr.needsUpdate = true;
                aAttr.needsUpdate = true;
            }, DISPLAY_CONFIG.fadeOutDuration);
        }
        // ─── 2) Full upstream cascade with per-hop delay ────────────────────────
        function cascadeChain(originId, maxDepth = 10, delayStep = 200) {
            const visited = new Set([originId]);

            function walk(id, depth) {
                if (depth >= maxDepth) return;
                const node = nodeMap.get(id);
                if (!node) return;

                // gather *all* upstream neighbors
                const neighbors = [
                    ... (node.data.references || []),
                    ...Object.keys(node.data.association_strengths || {})
                ];

                neighbors.forEach(tgtId => {
                    if (visited.has(tgtId)) return;
                    visited.add(tgtId);

                    // find the edge object (bi-directional)
                    const edgeObj = edges.find(e =>
                        (e.source === id && e.target === tgtId) ||
                        (e.source === tgtId && e.target === id)
                    );
                    if (!edgeObj) return;

                    // schedule a pulse with increasing delay
                    setTimeout(() => {
                        const peak = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, edgeObj.weight);
                        pulseEdge(edgeObj.index, peak);
                    }, depth * delayStep);

                    // recurse upstream from this neighbor
                    walk(tgtId, depth + 1);
                });
            }

            // start the cascade
            walk(originId, 1);
        }


        function flashNeighbours(nodeId) {
            edges.forEach(e => {
                if (e.source === nodeId || e.target === nodeId) pulseEdge(e.index);
            });
        }


        function triggerChain(nodeId, depth = 0) {
            if (!nodeId || depth > DISPLAY_CONFIG.maxChainDepth) return;

            edges.forEach(e => {
                const nbr = e.source === nodeId ? e.target
                    : e.target === nodeId ? e.source
                        : null;
                if (!nbr) return;

                const delay = DISPLAY_CONFIG.chainDelay * 1000 * (depth + 1);
                const base = DISPLAY_CONFIG.lineBaseOpacity * Math.min(1, e.weight);

                setTimeout(() => pulseEdge(e.index, base), delay);
                setTimeout(() => triggerChain(nbr, depth + 1), delay);
            });
        }


        function onPointerMove(ev) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('click', onClick);

        function onClick(ev) {
            // update pointer & do the raycast
            onPointerMove(ev);
            if (!instMesh) {
                // clicked without any mesh loaded → re-enable auto-scroll
                autoScrollEnabled = true;
                return;
            }

            scene.updateMatrixWorld();
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObject(instMesh, false)[0];

            // if you clicked empty space (or missed), re-enable auto-scroll
            if (!hit || hit.instanceId === undefined) {
                autoScrollEnabled = true;
                return;
            }

            // you clicked a node → pause auto-scroll
            autoScrollEnabled = false;

            // identify which context_id
            const clickedIdx = hit.instanceId;
            const ctxEntry = [...nodeMap.entries()]
                .find(([, n]) => n._instanceIndex === clickedIdx);
            if (!ctxEntry) return;
            const [ctxId, node] = ctxEntry;

            // remember selection & recolour immediately
            hovered = selectedId = ctxId;
            applyFilters();

            // show JSON preview
            selPane.textContent = JSON.stringify(node.data, null, 2);

            // build the detail table
            detailPanel.innerHTML = '';
            const ts0 = parseTimestamp(node.data.timestamp).getTime();
            const tbl = document.createElement('table');
            for (const [k, v] of Object.entries(node.data)) {
                const tr = document.createElement('tr');
                const tdK = document.createElement('td');
                const tdV = document.createElement('td');
                tdK.textContent = k;

                if (k === 'references' && Array.isArray(v)) {
                    v.forEach(rid => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = rid;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };

                        const ref = nodeMap.get(rid);
                        if (ref) {
                            const delta = ts0 - parseTimestamp(ref.data.timestamp).getTime();
                            const decay = Math.exp(-(delta / 86_400_000) / 7).toFixed(2);
                            const span = document.createElement('span');
                            span.style.marginLeft = '6px';
                            span.textContent = `(decay: ${decay})`;
                            a.appendChild(span);
                        }
                        tdV.appendChild(a);
                    });

                } else if (k === 'association_strengths' && typeof v === 'object') {
                    Object.entries(v).forEach(([rid, w]) => {
                        const a = document.createElement('a');
                        a.className = 'ref-link';
                        a.textContent = `${rid} (${w})`;
                        a.onclick = e => { e.preventDefault(); tweenToNode(rid); };
                        tdV.appendChild(a);
                    });

                } else {
                    tdV.textContent = typeof v === 'object' ? JSON.stringify(v) : v;
                }

                tr.append(tdK, tdV);
                tbl.appendChild(tr);
            }
            detailPanel.appendChild(tbl);

            // visual feedback on graph
            highlightPathFrom(ctxId);
            triggerChain(ctxId, 0);
            tweenToNode(ctxId);
            cascadeChain(ctxId);

            // scroll & highlight in sidebar
            document.querySelectorAll('.sidebar-item-highlight')
                .forEach(el => el.classList.remove('sidebar-item-highlight'));

            const dropdown = document.getElementById(`dropdown-${ctxId}`);
            if (dropdown) dropdown.style.display = 'block';

            const header = document.getElementById(`header-${ctxId}`);
            if (header) {
                header.classList.add('sidebar-item-highlight');
                header.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }



        function buildTraversalPath(id) {
            traversalPath = [id];
            let cur = id;
            while (true) {
                const refs = nodeMap.get(cur).data.references || [];
                if (!refs[0] || !nodeMap.has(refs[0])) break;
                cur = refs[0];
                traversalPath.push(cur);
            }
            pathIndex = 0;
        }


        timeToggle.addEventListener('click', () => {
            timeMode = !timeMode;
            timeToggle.textContent = timeMode ? 'Dolly ON' : 'Time Mode';
            controls.enableRotate = !timeMode;
        });

        fileSelector.addEventListener('change', () => loadGraph());
        ageSel.addEventListener('change', applyFilters);

        // ─── header clocks ────────────────────────────────
        const now = new Date();
        const viewTime = new Date(now - graphGroup.position.y * LAYOUT_CONFIG.msPerUnit);

        nowLbl.textContent = 'Now:  ' + now.toLocaleString();
        viewLbl.textContent = 'View: ' + viewTime.toLocaleString();
        /********************************************************************
         *  Animation loop  (COMPLETE, SELF-CONTAINED)
         *******************************************************************/
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // ——— 1) smooth scroll/drift —————————————————————————————
            if (Math.abs(scrollVelocity) > 1e-4) {
                yScrollOffset = Math.min(0, yScrollOffset + scrollVelocity);
                scrollVelocity *= SCROLL_FRICTION;
            } else {
                scrollVelocity = 0;
            }
            const nowMs = Date.now();
            const dt = nowMs - lastDriftT;
            yScrollOffset += (dt * LAYOUT_CONFIG.driftFactor) / MS_PER_UNIT;
            lastDriftT = nowMs;
            graphGroup.position.y = yScrollOffset;

            // update header clocks
            const nowDate = new Date();
            const elapsedMs = -yScrollOffset * MS_PER_UNIT;
            const viewDate = new Date(nowDate - elapsedMs);
            nowLbl.textContent = 'Now:  ' + nowDate.toLocaleString();
            viewLbl.textContent = 'View: ' + viewDate.toLocaleString();
            scrollBoost = Math.max(1, scrollBoost * BOOST_DECAY);

            // ——— 2) camera fly-to tween —————————————————————————————
            if (cameraTween) {
                const tCam = Math.min((performance.now() - cameraTween.start) / cameraTween.duration, 1);
                camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, tCam);
                controls.target.lerpVectors(cameraTween.fromTarget, cameraTween.toTarget, tCam);
                if (tCam >= 1) cameraTween = null;
            }

            // ——— 3) node-position tween + scale-tween + edge update —————————————————
            const nowT = performance.now();
            let moved = false;

            // a) any D3/tween position updates?
            nodeMap.forEach(entry => {
                if (!entry.tweenStart) return;
                const t = Math.min((nowT - entry.tweenStart) / entry.tweenDuration, 1);
                const ip = entry.prevPos.clone().lerp(entry.pos, t);
                const mat = new THREE.Matrix4().compose(ip, new THREE.Quaternion(), new THREE.Vector3(1, 1, 1));
                instMesh.setMatrixAt(entry._instanceIndex, mat);
                moved = true;
                if (t === 1) {
                    delete entry.tweenStart;
                    entry.prevPos.copy(entry.pos);
                }
            });

            // b) scale-tween for new nodes
            nodeMap.forEach(entry => {
                if (!entry.scaleTweenStart) return;
                const t2 = Math.min((nowT - entry.scaleTweenStart) / entry.scaleTweenDuration, 1);
                const scale = entry.scalePrev.clone().lerp(entry.scaleTarget, t2);
                const mat = new THREE.Matrix4().compose(entry.pos, new THREE.Quaternion(), scale);
                instMesh.setMatrixAt(entry._instanceIndex, mat);
                moved = true;
                if (t2 === 1) {
                    delete entry.scaleTweenStart;
                }
            });

            if (moved) {
                instMesh.instanceMatrix.needsUpdate = true;
                updateEdgeMeshes();
            }

            // ——— 4) hover & click feedback —————————————————————————————
            if (instMesh) {
                scene.updateMatrixWorld();
                raycaster.setFromCamera(pointer, camera);
                const hit = raycaster.intersectObject(instMesh, false)[0];
                if (hit && hit.instanceId !== undefined) {
                    const idx = hit.instanceId;
                    if (idx !== hoveredIdx) {
                        hoveredIdx = idx;
                        const found = [...nodeMap.entries()].find(([, n]) => n._instanceIndex === idx);
                        if (found) {
                            const [ctxId, node] = found;
                            hovered = ctxId;
                            selPane.textContent = JSON.stringify(node.data, null, 2);
                            populateDetail(ctxId);
                            flashNeighbours(ctxId);
                            const el = document.querySelector(`[id^="sidebar-item-container-${ctxId}-"]`);
                            if (el) {
                                document.querySelectorAll('.sidebar-item-highlight')
                                    .forEach(e => e.classList.remove('sidebar-item-highlight'));
                                el.classList.add('sidebar-item-highlight');
                                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                } else {
                    hoveredIdx = hovered = null;
                    document.querySelectorAll('.sidebar-item-highlight')
                        .forEach(e => e.classList.remove('sidebar-item-highlight'));
                }
            }
            if (hovered !== previousHoveredId) {
                previousHoveredId = hovered;
                if (instMesh) instMesh.material.emissiveIntensity = 0;
            }

            // ——— 5) final render —————————————————————————————
            renderer.render(scene, camera);
        }



        // start it up
        animate();


        ensureEdgeAlphaAttr();   // make alpha buffer immediately
        rebuildEdges();
        populateFileSelector()
            .then(loadGraph)
            .then(() => {
                // after your initial loadGraph, seed lastContextId:
                if (allData.length) {
                    lastContextId = allData[allData.length - 1].context_id;
                }
                setInterval(pollForNew, POLL_INTERVAL);
            })
            .catch(err => {
                console.error(err);
                loadGraph().then(() => {
                    if (allData.length) lastContextId = allData[allData.length - 1].context_id;
                    setInterval(pollForNew, POLL_INTERVAL);
                });
            });
        // handle resize
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>