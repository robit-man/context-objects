<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Face + Hand Tracking Grid Demo (Spotlight)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    #info {
      position: absolute; top: 0; left: 0; padding: 8px;
      color: #eee; font-family: sans-serif; z-index: 1;
    }
  </style>

  <!-- three.js importmap -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="info">Face + Hand Tracking Grid Demo with Spotlight</div>

  <script type="module">
    import * as THREE          from 'three';
    import { OrbitControls }   from 'three/addons/controls/OrbitControls.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { GLTFLoader }      from 'three/addons/loaders/GLTFLoader.js';
    import { KTX2Loader }      from 'three/addons/loaders/KTX2Loader.js';
    import { MeshoptDecoder }  from 'three/addons/libs/meshopt_decoder.module.js';
    import { GUI }             from 'three/addons/libs/lil-gui.module.min.js';
    import vision              from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

    const { FaceLandmarker, HandLandmarker, FilesetResolver } = vision;


        // — blendshape map (original) —
        const blendshapesMap = { /* … your full map here … */
            browDownLeft: 'browDown_L', browDownRight: 'browDown_R',
            browInnerUp: 'browInnerUp', browOuterUpLeft: 'browOuterUp_L', browOuterUpRight: 'browOuterUp_R',
            cheekPuff: 'cheekPuff', cheekSquintLeft: 'cheekSquint_L', cheekSquintRight: 'cheekSquint_R',
            eyeBlinkLeft: 'eyeBlink_L', eyeBlinkRight: 'eyeBlink_R',
            eyeLookDownLeft: 'eyeLookDown_L', eyeLookDownRight: 'eyeLookDown_R',
            eyeLookInLeft: 'eyeLookIn_L', eyeLookInRight: 'eyeLookIn_R',
            eyeLookOutLeft: 'eyeLookOut_L', eyeLookOutRight: 'eyeLookOut_R',
            eyeLookUpLeft: 'eyeLookUp_L', eyeLookUpRight: 'eyeLookUp_R',
            eyeSquintLeft: 'eyeSquint_L', eyeSquintRight: 'eyeSquint_R',
            eyeWideLeft: 'eyeWide_L', eyeWideRight: 'eyeWide_R',
            jawForward: 'jawForward', jawLeft: 'jawLeft', jawOpen: 'jawOpen', jawRight: 'jawRight',
            mouthClose: 'mouthClose', mouthDimpleLeft: 'mouthDimple_L', mouthDimpleRight: 'mouthDimple_R',
            mouthFrownLeft: 'mouthFrown_L', mouthFrownRight: 'mouthFrown_R',
            mouthFunnel: 'mouthFunnel', mouthLeft: 'mouthLeft',
            mouthLowerDownLeft: 'mouthLowerDown_L', mouthLowerDownRight: 'mouthLowerDown_R',
            mouthPressLeft: 'mouthPress_L', mouthPressRight: 'mouthPress_R',
            mouthPucker: 'mouthPucker', mouthRight: 'mouthRight',
            mouthRollLower: 'mouthRollLower', mouthRollUpper: 'mouthRollUpper',
            mouthShrugLower: 'mouthShrugLower', mouthShrugUpper: 'mouthShrugUpper',
            mouthSmileLeft: 'mouthSmile_L', mouthSmileRight: 'mouthSmile_R',
            mouthStretchLeft: 'mouthStretch_L', mouthStretchRight: 'mouthStretch_R',
            mouthUpperUpLeft: 'mouthUpperUp_L', mouthUpperUpRight: 'mouthUpperUp_R',
            noseSneerLeft: 'noseSneer_L', noseSneerRight: 'noseSneer_R'
        };

    let video, faceLandmarker, handLandmarker;

    // — three.js setup —
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,1.6,0);
    controls.enableDamping = true;

    // — single spotlight on camera —
    const spot = new THREE.SpotLight(0xffffff, 2, 10, Math.PI/8, 0.2, 1);
    scene.add(spot);
    scene.add(spot.target);
    // ensure it starts aimed at the face
    spot.target.position.copy(controls.target);

    // — realistic ground grid —
    let gridSize=10, gridDivs=10;
    let grid=new THREE.GridHelper(gridSize,gridDivs,0x444444,0x444444);
    scene.add(grid);

    // — environment for reflections —
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;

    // — load FaceCap GLTF with StandardMaterial —
    let faceMesh, eyeL, eyeR;
    const ktx2 = new KTX2Loader()
      .setTranscoderPath('https://unpkg.com/three@0.152.2/examples/jsm/libs/basis/')
      .detectSupport(renderer);

    new GLTFLoader()
      .setKTX2Loader(ktx2)
      .setMeshoptDecoder(MeshoptDecoder)
      .load('https://threejs.org/examples/models/gltf/facecap.glb', gltf => {
        const mesh = gltf.scene.children[0];
        mesh.position.set(0,1.6,0);
        scene.add(mesh);

        const head = mesh.getObjectByName('mesh_2');
        head.material = new THREE.MeshPhongMaterial({
          color: 0x444444,
          roughness: 0.5,
          metalness: 0.1,
          wireframe: false,
        });
        eyeL = mesh.getObjectByName('eyeLeft');
        eyeL.material = new THREE.MeshBasicMaterial({
          color: 0xffaa00,
          wireframe: false,
        });
        eyeR = mesh.getObjectByName('eyeRight');
        eyeR.material = new THREE.MeshBasicMaterial({
          color: 0xffaa00,
          wireframe: false,
        });


        faceMesh = head;
        

        const gui = new GUI(); gui.close();
        const inf = head.morphTargetInfluences;
        for (const [k,i] of Object.entries(head.morphTargetDictionary)) {
          gui.add(inf,i,0,1,0.01).name(k.replace('blendShape1.','')).listen(inf);
        }

        renderer.setAnimationLoop(animate);
      });

    // — optional video-plane (still BasicMaterial) —
    video=document.createElement('video');
    video.style.display='none';
    document.body.appendChild(video);
    const vtex=new THREE.VideoTexture(video);
    const plane=new THREE.Mesh(
      new THREE.PlaneGeometry(1.6,1.2),
      new THREE.MeshBasicMaterial({map:vtex,depthWrite:true})
    );
    plane.position.set(3,1.6,0);
    //scene.add(plane);

    // — MediaPipe initialization —
    const fileset = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
    );
    faceLandmarker = await FaceLandmarker.createFromOptions(fileset,{
      baseOptions:{
        modelAssetPath:'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
        delegate:'GPU'
      },
      outputFaceBlendshapes:true,
      outputFacialTransformationMatrixes:true,
      runningMode:'VIDEO',
      numFaces:1
    });
    handLandmarker = await HandLandmarker.createFromOptions(fileset,{
      baseOptions:{
        modelAssetPath:'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
        delegate:'GPU'
      },
      outputHandLandmarks:true,
      outputHandedness:true,
      runningMode:'VIDEO',
      numHands:2
    });

    // — start webcam —
    try {
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}});
      video.srcObject=s; await video.play();
    } catch(e){ console.error(e); }

    // — helpers —
    const transform=new THREE.Object3D();
    const eyeLimit=THREE.MathUtils.degToRad(30);
    const prevEuler=new THREE.Euler();

    function mapRange(v,a,b,c,d){return c+(d-c)*((v-a)/(b-a));}
    function recreateGrid(){
      scene.remove(grid);
      grid=new THREE.GridHelper(gridSize,gridDivs,0x444444,0x444444);
      scene.add(grid);
    }

    function orbitCamera(dY,dP,dR){
      const T=controls.target, O=camera.position.clone().sub(T);
      const qy=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),dY);
      O.applyQuaternion(qy);
      const R=new THREE.Vector3().crossVectors(camera.up,O).normalize();
      const qp=new THREE.Quaternion().setFromAxisAngle(R,dP);
      O.applyQuaternion(qp);
      camera.position.copy(T).add(O);
      // roll: tilt camera.up around forward
      const F=T.clone().sub(camera.position).normalize();
      const qr=new THREE.Quaternion().setFromAxisAngle(F,dR);
      camera.up.applyQuaternion(qr);
      camera.lookAt(T);
    }

    // — main loop —
    function animate(){
      if(video.readyState>=HTMLMediaElement.HAVE_METADATA){
        const t=performance.now();
        const f=faceLandmarker.detectForVideo(video,t);
        const h=handLandmarker.detectForVideo(video,t);

        if(f.faceBlendshapes?.length){
          const cats=f.faceBlendshapes[0].categories;
          const eyeScore={lH:0,rH:0,lV:0,rV:0};
          cats.forEach(({categoryName,score})=>{
            const idx=faceMesh.morphTargetDictionary[blendshapesMap[categoryName]];
            if(idx!==undefined) faceMesh.morphTargetInfluences[idx]=score;
            switch(categoryName){
              case'eyeLookInLeft':   eyeScore.lH+=score;break;
              case'eyeLookOutLeft':  eyeScore.lH-=score;break;
              case'eyeLookInRight':  eyeScore.rH-=score;break;
              case'eyeLookOutRight': eyeScore.rH+=score;break;
              case'eyeLookUpLeft':   eyeScore.lV-=score;break;
              case'eyeLookDownLeft': eyeScore.lV+=score;break;
              case'eyeLookUpRight':  eyeScore.rV-=score;break;
              case'eyeLookDownRight':eyeScore.rV+=score;break;
            }
          });
          eyeL.rotation.z=eyeScore.lH*eyeLimit;
          eyeR.rotation.z=eyeScore.rH*eyeLimit;
          eyeL.rotation.x=eyeScore.lV*eyeLimit;
          eyeR.rotation.x=eyeScore.rV*eyeLimit;

          // eyebrow → FOV
          const brow=(cats.find(c=>c.categoryName==='browInnerUp')?.score||0);
          camera.fov=THREE.MathUtils.lerp(camera.fov,60+brow*40,0.1);
          camera.updateProjectionMatrix();

          // blink → spotlight intensity [0…2]
          const bL=cats.find(c=>c.categoryName==='eyeBlinkLeft')?.score||0;
          const bR=cats.find(c=>c.categoryName==='eyeBlinkRight')?.score||0;
          const open=1-((bL+bR)/2);
          spot.intensity=THREE.MathUtils.lerp(spot.intensity,open*2 - 1,0.1);
          console.log(spot.intensity)

          // head-pose → orbit+roll
          if(f.facialTransformationMatrixes?.length){
            const m=f.facialTransformationMatrixes[0].data;
            transform.matrix.fromArray(m);
            transform.matrix.decompose(transform.position,transform.quaternion,transform.scale);
            const e=new THREE.Euler().setFromQuaternion(transform.quaternion,'YXZ');
            const dY=e.y-prevEuler.y, dP=e.x-prevEuler.x, dR=e.z-prevEuler.z;
            orbitCamera(-dY,-dP,-dR);
            prevEuler.copy(e);
            // keep spotlight on camera & aimed at face
            spot.position.copy(camera.position);
            spot.target.position.copy(controls.target);
            spot.target.updateMatrixWorld();
          }
        }

        // hand pinch → grid size/divisions
        if(h.landmarks?.length){
          h.landmarks.forEach((lm,i)=>{
            const hand=h.handedness[i].categoryName;
            const t=lm[4], x=lm[8];
            const d=Math.hypot(t.x-x.x,t.y-x.y,t.z-x.z);
            if(hand==='Left'){
              gridSize=mapRange(THREE.MathUtils.clamp(d,0.05,0.25),0.05,0.25,5,30);
              recreateGrid();
            } else {
              gridDivs=Math.round(mapRange(THREE.MathUtils.clamp(d,0.05,0.25),0.05,0.25,4,64));
              recreateGrid();
            }
          });
        }
      }

      controls.update();
      renderer.render(scene,camera);
    }

    window.addEventListener('resize',()=>{
      renderer.setSize(innerWidth,innerHeight);
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
