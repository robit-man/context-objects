<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Stereo View with IPD & Shared Lighting + Orientation Permission</title>
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            /* ← remove that safe‑area padding! */
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
        }

        #info {
            position: absolute;
            top: 0;
            left: 0;
            padding: 8px;
            color: #eee;
            font-family: sans-serif;
            z-index: 2
        }

        #settingsBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            display: flex;
            flex-flow: row;
            justify-content: center;
            background: #444;
            color: #eee;
            border: none;
            border-radius: 20px;
            font-size: 18px;
            cursor: pointer;
            z-index: 2;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3;
        }

        .modal-content {
            background: #333;
            color: #fff;
            padding: 20px;
            border-radius: 8px;
            width: 280px;
            text-align: center;
            font-family: sans-serif;
        }

        .modal-content h3 {
            margin-top: 0
        }

        .modal-content label {
            display: block;
            margin: 12px 0 4px
        }

        .modal-content input[type=range] {
            width: 100%
        }

        .modal-content button {
            margin-top: 16px;
            padding: 8px 16px;
            background: #555;
            color: #eee;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

canvas {
  flex: 1;          /* split 50/50 by flex on parent */
  height: 100%;     /* full viewport height */
  display: block;
}
    </style>

    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>

<body>
    <button id="settingsBtn">⚙️</button>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h3>Settings</h3>
            <label for="ipdSlider">IPD: <span id="ipdValue"></span> m</label>
            <input type="range" id="ipdSlider" min="0" max="0.15" step="0.001" />
            <button id="closeSettings">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';
        const { FaceLandmarker, HandLandmarker, FilesetResolver } = vision;

        // — blendshape map (original) —
        const blendshapesMap = {
            browDownLeft: 'browDown_L', browDownRight: 'browDown_R',
            browInnerUp: 'browInnerUp', browOuterUpLeft: 'browOuterUp_L', browOuterUpRight: 'browOuterUp_R',
            cheekPuff: 'cheekPuff', cheekSquintLeft: 'cheekSquint_L', cheekSquintRight: 'cheekSquint_R',
            eyeBlinkLeft: 'eyeBlink_L', eyeBlinkRight: 'eyeBlink_R',
            eyeLookDownLeft: 'eyeLookDown_L', eyeLookDownRight: 'eyeLookDown_R',
            eyeLookInLeft: 'eyeLookIn_L', eyeLookInRight: 'eyeLookIn_R',
            eyeLookOutLeft: 'eyeLookOut_L', eyeLookOutRight: 'eyeLookOut_R',
            eyeLookUpLeft: 'eyeLookUp_L', eyeLookUpRight: 'eyeLookUp_R',
            eyeSquintLeft: 'eyeSquint_L', eyeSquintRight: 'eyeSquint_R',
            eyeWideLeft: 'eyeWide_L', eyeWideRight: 'eyeWide_R',
            jawForward: 'jawForward', jawLeft: 'jawLeft', jawOpen: 'jawOpen', jawRight: 'jawRight',
            mouthClose: 'mouthClose', mouthDimpleLeft: 'mouthDimple_L', mouthDimpleRight: 'mouthDimple_R',
            mouthFrownLeft: 'mouthFrown_L', mouthFrownRight: 'mouthFrown_R',
            mouthFunnel: 'mouthFunnel', mouthLeft: 'mouthLeft',
            mouthLowerDownLeft: 'mouthLowerDown_L', mouthLowerDownRight: 'mouthLowerDown_R',
            mouthPressLeft: 'mouthPress_L', mouthPressRight: 'mouthPress_R',
            mouthPucker: 'mouthPucker', mouthRight: 'mouthRight',
            mouthRollLower: 'mouthRollLower', mouthRollUpper: 'mouthRollUpper',
            mouthShrugLower: 'mouthShrugLower', mouthShrugUpper: 'mouthShrugUpper',
            mouthSmileLeft: 'mouthSmile_L', mouthSmileRight: 'mouthSmile_R',
            mouthStretchLeft: 'mouthStretch_L', mouthStretchRight: 'mouthStretch_R',
            mouthUpperUpLeft: 'mouthUpperUp_L', mouthUpperUpRight: 'mouthUpperUp_R',
            noseSneerLeft: 'noseSneer_L', noseSneerRight: 'noseSneer_R'
        };

        // ----- IPD SETTINGS -----
        const ipdKey = 'stereo-ipd';
        let IPD = parseFloat(localStorage.getItem(ipdKey)) || 0.06;
        const settingsBtn = document.getElementById('settingsBtn');
        const modal = document.getElementById('settingsModal');
        const closeSettings = document.getElementById('closeSettings');
        const ipdSlider = document.getElementById('ipdSlider');
        const ipdValueSpan = document.getElementById('ipdValue');
        settingsBtn.addEventListener('click', () => {
            ipdSlider.value = IPD;
            ipdValueSpan.textContent = IPD.toFixed(3);
            modal.style.display = 'flex';
        });
        closeSettings.addEventListener('click', () => modal.style.display = 'none');
        ipdSlider.addEventListener('input', () => {
            IPD = parseFloat(ipdSlider.value);
            ipdValueSpan.textContent = IPD.toFixed(3);
            localStorage.setItem(ipdKey, IPD);
        });

        // Three.js setup
        let video, faceLandmarker, handLandmarker;
        let faceMesh, eyeL, eyeR;

        const rendererL = new THREE.WebGLRenderer({ antialias: true });
        const rendererR = new THREE.WebGLRenderer({ antialias: true });
        [rendererL, rendererR].forEach(r => {
            r.setPixelRatio(window.devicePixelRatio);
            r.outputEncoding = THREE.sRGBEncoding;
            r.toneMapping = THREE.ACESFilmicToneMapping;
            r.toneMappingExposure = 1;
            document.body.appendChild(r.domElement);
            r.setScissorTest(true);
        });

        // single scene + environment
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaeeff);
        import { WebGLRenderer } from 'three';

        const _envRenderer = new WebGLRenderer();              // offscreen
        const _pmremGen = new THREE.PMREMGenerator(_envRenderer);
        scene.environment = _pmremGen.fromScene(
            new RoomEnvironment(), 0.04
        ).texture;
        _pmremGen.dispose();
        _envRenderer.dispose();

        // shared lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // cameras
        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 15);
        const leftCam = camera.clone();
        const rightCam = camera.clone();

        function updateSizes() {
            // 3) use visualViewport if available
            const vw = window.visualViewport?.width ?? window.innerWidth;
            const vh = window.visualViewport?.height ?? window.innerHeight;

            // update camera aspects
            camera.aspect = vw / vh;
            camera.updateProjectionMatrix();

            leftCam.aspect = (vw / 2) / vh;
            leftCam.updateProjectionMatrix();

            rightCam.aspect = (vw / 2) / vh;
            rightCam.updateProjectionMatrix();

            // resize each renderer to half width, full height
            rendererL.setSize(vw / 2, vh);
            rendererR.setSize(vw / 2, vh);
        }
        updateSizes();

        // terrain
        const size = 1000;
        const segments = 100;
        const terrainGeo = new THREE.PlaneGeometry(size, size, segments, segments);
        const posAttr = terrainGeo.attributes.position;
        for (let i = 0; i < posAttr.count; i++) {
            posAttr.setZ(i, (Math.random() - 0.5) * 5);
        }
        terrainGeo.computeVertexNormals();
        const terrainMat = new THREE.MeshStandardMaterial({
            color: 0x556B2F, flatShading: true, metalness: 0.1, roughness: 0.8
        });
        const terrain = new THREE.Mesh(terrainGeo, terrainMat);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -2;
        terrain.receiveShadow = true;
        scene.add(terrain);

        scene.add(new THREE.AxesHelper(2));
        const cube = new THREE.Mesh(
            new THREE.BoxGeometry(1, 1, 1),
            new THREE.MeshStandardMaterial({ color: 0xff0000 })
        );
        cube.position.set(2, 0.5, 0);
        scene.add(cube);

        const fingerGroup = new THREE.Group();
        scene.add(fingerGroup);

        // load FaceCap + video
        const ktx2 = new KTX2Loader()
            .setTranscoderPath('https://unpkg.com/three@0.152.2/examples/jsm/libs/basis/')
            .detectSupport(rendererL);
        new GLTFLoader()
            .setKTX2Loader(ktx2)
            .setMeshoptDecoder(MeshoptDecoder)
            .load('https://threejs.org/examples/models/gltf/facecap.glb', gltf => {
                const mesh = gltf.scene.children[0];
                mesh.position.set(0, 1.6, 0);
                scene.add(mesh);
                const videoTex = new THREE.VideoTexture(video);
                videoTex.minFilter = THREE.LinearFilter;
                videoTex.magFilter = THREE.LinearFilter;
                videoTex.format = THREE.RGBAFormat;
                videoTex.flipY = false;
                faceMesh = mesh.getObjectByName('mesh_2');
                faceMesh.material = new THREE.MeshStandardMaterial({
                    map: videoTex, roughness: 0.7, metalness: 0
                });
                ['eyeLeft', 'eyeRight'].forEach(name => {
                    mesh.getObjectByName(name).material = new THREE.MeshPhongMaterial({
                        color: 0xaa0000, wireframe: true, shininess: 1
                    });
                });
                mesh.traverse(n => {
                    if (n.isMesh && /tooth/i.test(n.name)) {
                        n.material = new THREE.MeshPhongMaterial({ color: 0xaa0000, shininess: 1 });
                    }
                });
                eyeL = mesh.getObjectByName('eyeLeft');
                eyeR = mesh.getObjectByName('eyeRight');
                animate();
            });

        // hidden video
        video = document.createElement('video');
        video.style.display = 'none';
        document.body.appendChild(video);

        // MediaPipe init
        const fileset = await FilesetResolver.forVisionTasks(
            'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
        );
        faceLandmarker = await FaceLandmarker.createFromOptions(fileset, {
            baseOptions: {
                modelAssetPath:
                    'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                delegate: 'GPU'
            },
            outputFaceBlendshapes: true,
            outputFacialTransformationMatrixes: true,
            runningMode: 'VIDEO',
            numFaces: 1
        });
        handLandmarker = await HandLandmarker.createFromOptions(fileset, {
            baseOptions: {
                modelAssetPath:
                    'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                delegate: 'GPU'
            },
            outputHandLandmarks: true,
            outputHandedness: true,
            runningMode: 'VIDEO',
            numHands: 4
        });

        // start camera
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
            video.srcObject = stream;
            await video.play();
        } catch (e) {
            console.error('Camera error:', e);
        }

        // orientation permission logic
        let orientationInitialized = false;
        const zee = new THREE.Vector3(0, 0, 1);
        const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
        const q0 = new THREE.Quaternion();

        function onDeviceOrientation(evt) {
            // ignore all-zero until granted
            if (!orientationInitialized && evt.alpha === 0 && evt.beta === 0 && evt.gamma === 0) {
                initOrientation();
                return;
            }
            orientationInitialized = true;
            const orientDeg = screen.orientation?.angle ?? window.orientation ?? 0;
            const orient = THREE.MathUtils.degToRad(orientDeg);
            const alpha = THREE.MathUtils.degToRad(evt.alpha || 0);
            const beta = THREE.MathUtils.degToRad(evt.beta || 0);
            const gamma = THREE.MathUtils.degToRad(evt.gamma || 0);
            const euler = new THREE.Euler(beta, alpha, -gamma, 'YXZ');

            camera.quaternion.setFromEuler(euler);
            camera.quaternion.multiply(q1);
            q0.setFromAxisAngle(zee, -orient);
            camera.quaternion.multiply(q0);

            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            dirLight.target.position.copy(camera.position).add(forward);
            dirLight.target.updateMatrixWorld();
        }

        async function initOrientation() {
            if (orientationInitialized) return;
            if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                try {
                    const state = await DeviceOrientationEvent.requestPermission();
                    if (state !== 'granted') return;
                } catch (err) {
                    console.warn('Orientation permission error', err);
                    return;
                }
            }
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
        }

        // trigger on first tap
        window.addEventListener('click', initOrientation, { once: true });
        // also try immediately for non-iOS
        initOrientation();

        // render loop
        const raycaster = new THREE.Raycaster();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const boneConns = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8],
        [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16],
        [0, 17], [17, 18], [18, 19], [19, 20]];
        const eyeLimit = THREE.MathUtils.degToRad(30);

        function animate() {
            requestAnimationFrame(animate);

            if (video.readyState >= HTMLMediaElement.HAVE_METADATA) {
                const t = performance.now();
                const fRes = faceLandmarker.detectForVideo(video, t);
                const hRes = handLandmarker.detectForVideo(video, t);

                if (fRes.faceBlendshapes?.length) {
                    const cats = fRes.faceBlendshapes[0].categories;
                    const eyeScore = { lH: 0, rH: 0, lV: 0, rV: 0 };
                    cats.forEach(({ categoryName, score }) => {
                        const idx = faceMesh.morphTargetDictionary[blendshapesMap[categoryName]];
                        if (idx !== undefined) faceMesh.morphTargetInfluences[idx] = score;
                        switch (categoryName) {
                            case 'eyeLookInLeft': eyeScore.lH += score; break;
                            case 'eyeLookOutLeft': eyeScore.lH -= score; break;
                            case 'eyeLookInRight': eyeScore.rH -= score; break;
                            case 'eyeLookOutRight': eyeScore.rH += score; break;
                            case 'eyeLookUpLeft': eyeScore.lV -= score; break;
                            case 'eyeLookDownLeft': eyeScore.lV += score; break;
                            case 'eyeLookUpRight': eyeScore.rV -= score; break;
                            case 'eyeLookDownRight': eyeScore.rV += score; break;
                        }
                    });
                    eyeL.rotation.z = eyeScore.lH * eyeLimit;
                    eyeR.rotation.z = eyeScore.rH * eyeLimit;
                    eyeL.rotation.x = eyeScore.lV * eyeLimit;
                    eyeR.rotation.x = eyeScore.rV * eyeLimit;
                }

                while (fingerGroup.children.length) fingerGroup.remove(fingerGroup.children[0]);
                if (hRes.landmarks?.length) {
                    hRes.landmarks.forEach((lm, i) => {
                        const color = hRes.handednesses[i][0].categoryName === 'Left' ? 0x888888 : 0xaaaaaa;
                        const matJ = new THREE.MeshBasicMaterial({ color });
                        const matB = new THREE.LineBasicMaterial({ color });
                        lm.forEach(pt => {
                            const xN = (1 - pt.x) * 2 - 1, yN = -(pt.y * 2 - 1);
                            raycaster.setFromCamera({ x: xN, y: yN }, camera);
                            const world = new THREE.Vector3();
                            if (raycaster.ray.intersectPlane(groundPlane, world)) {
                                const sph = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), matJ);
                                sph.position.copy(world);
                                fingerGroup.add(sph);
                            }
                        });
                        boneConns.forEach(([a, b]) => {
                            const pa = lm[a], pb = lm[b];
                            const xa = (1 - pa.x) * 2 - 1, ya = -(pa.y * 2 - 1);
                            const xb = (1 - pb.x) * 2 - 1, yb = -(pb.y * 2 - 1);
                            raycaster.setFromCamera({ x: xa, y: ya }, camera);
                            const A = new THREE.Vector3(), B = new THREE.Vector3();
                            const hitA = raycaster.ray.intersectPlane(groundPlane, A);
                            raycaster.setFromCamera({ x: xb, y: yb }, camera);
                            const hitB = raycaster.ray.intersectPlane(groundPlane, B);
                            if (hitA && hitB) {
                                fingerGroup.add(new THREE.Line(
                                    new THREE.BufferGeometry().setFromPoints([A, B]),
                                    matB
                                ));
                            }
                        });
                    });
                }
            }

            const fullW = window.innerWidth, fullH = window.innerHeight;
            const halfW = fullW / 2, halfH = fullH;
            const shiftPx = (IPD / 0.15) * (halfW / 2);

            // left eye
            rendererL.setViewport(0, 0, halfW, halfH);
            rendererL.setScissor(0, 0, halfW, halfH);
            leftCam.position.copy(camera.position);
            leftCam.quaternion.copy(camera.quaternion);
            leftCam.setViewOffset(fullW, fullH, shiftPx, 0, halfW, halfH);
            leftCam.updateProjectionMatrix();
            rendererL.render(scene, leftCam);
            leftCam.clearViewOffset();

            // right eye
            rendererR.setViewport(0, 0, halfW, halfH);
            rendererR.setScissor(0, 0, halfW, halfH);
            rightCam.position.copy(camera.position);
            rightCam.quaternion.copy(camera.quaternion);
            rightCam.setViewOffset(fullW, fullH, fullW / 2 - shiftPx, 0, halfW, halfH);
            rightCam.updateProjectionMatrix();
            rendererR.render(scene, rightCam);
            rightCam.clearViewOffset();
        }

        animate();
        window.addEventListener('resize', updateSizes);
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', updateSizes);
        }    </script>
</body>

</html>